<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Sun, 15 Mar 2015 23:58:04 +0800</pubDate>
    <lastBuildDate>Sun, 15 Mar 2015 23:58:04 +0800</lastBuildDate>

    
    <item>
      <title>创业公司去留评测指南</title>
      <link>place_your_blog_url_here/other/2015/03/13/Leave-Or-Stay.html</link>
      <pubDate>13 Mar 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/other/2015/03/13/Leave-Or-Stay</guid>
      <description>&lt;h2 id=&quot;origin&quot;&gt;Origin&lt;/h2&gt;

&lt;p&gt;原帖：http://www.v2ex.com/t/176503&lt;/p&gt;

&lt;p&gt;只是我睡前临时起意写的，第二天觉得反响不错又整理了一遍&lt;/p&gt;

&lt;p&gt;今年一月份离职，过年考驾照到现在还没有上班（无业游民中）。本来是想闲下来，写写这两年多来在创业公司的经历（有一年多的实习）发发牢骚，总结总结。但觉得这样有些不厚道，外加原公司无论是老板还是员工人都挺好，自己成长得也挺好。&lt;/p&gt;

&lt;p&gt;决定把一些在工作中，非技术的东西整理出来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以便自己下次再找公司团队，或者将来有一天自己创业时，做为员工时候的一些期望，有个东西进行参考。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但首先，我承认我没自己开过公司，没当领导，以下一切都是我个人在家无聊的意淫的产物。但这一切也是源于我个人在之前的认识的一个总结，不觉得有_浮夸或者过分的要求_。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些标准的参考来源于：  &lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;本人自己的亲身经历，(常见的BAT高管离职创业，海归回国创业，大V创业)  &lt;/li&gt;
  &lt;li&gt;在招聘贴里，经常可以提供的条件，且合理的（主要参考是物质上）  &lt;/li&gt;
  &lt;li&gt;自己家父创业多年，虽不算成功，但员工管理还是很有心得。且一并见过不少多年创业后成功的人 （虽然不是互联网企业的），但他们对待自己的员工的经验我觉得是可以学习与参与的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果有意见或者不爽，可以直接mailto:wing.of.war.1980th@gmail.com进行电邮联系~&lt;/p&gt;

&lt;h2 id=&quot;core-factor&quot;&gt;Core Factor&lt;/h2&gt;

&lt;p&gt;这是核心理念项，就是员工个人对于公司最主观的评分，如果员工个人对于这部分都不满意，达不到一定预期，比如低于15分~10分的，基本可以考虑走人，不需要犹豫，如果在15~35分区间的，可以继续参考Advance部分。35分以上则请继续努力~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：这是员工自己的主观判断，公司如果想自检可以从&lt;code&gt;Advance&lt;/code&gt;部分开始。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;mental&quot;&gt;Mental（精神层面）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;公司的创业项目有不错的前景（5分）&lt;/li&gt;
  &lt;li&gt;员工自己认可公司的发展前景和项目（5分）&lt;/li&gt;
  &lt;li&gt;觉得与自己未来的发展一致（5分）&lt;/li&gt;
  &lt;li&gt;自己有足够的实力和意愿来公司工作（5分）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;substance&quot;&gt;Substance（物质层面）&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;公司拿到融资风投等，或者自身是盈利的（5分）&lt;/li&gt;
  &lt;li&gt;员工有行业平均水平的工资（0~15分，平均水平10分）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;advance-factor&quot;&gt;Advance Factor&lt;/h2&gt;

&lt;p&gt;如果核心层面上，员工个人可以和公司的发展做到三观吻合，那么再考察下面这些项目。
&lt;code&gt;Founders&lt;/code&gt;的档次决定了创业公司的基本调调，有着自己的特点进行灵活&lt;code&gt;Manage&lt;/code&gt;，然后招到或者从自己的人脉中找到行业中靠谱的&lt;code&gt;Teammate&lt;/code&gt;，这样每个有着自己的&lt;code&gt;Job&lt;/code&gt; ,从人文关怀或者为了提高生产效率的角度，也会配备足够完备（至少会慢慢补齐）的设备&lt;code&gt;Facility&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后再回到项目&lt;code&gt;Project&lt;/code&gt;本身，倒反而不重要了。&lt;strong&gt;找到靠谱的团队，就能做出NB的事&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;founder&quot;&gt;Founder（创始人）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;有2~5个左右的Co-Founder，或者是一个 &lt;code&gt;人格魅力和有做事魄力&lt;/code&gt;的Boss &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;Boss要有做&lt;code&gt;企业家&lt;/code&gt;的梦想和觉悟（特别是曾经在大公司做过高管的，&lt;code&gt;要有做企业的觉悟&lt;/code&gt;，而不是带团队）&lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;Boss做技术出生，乐于使用新技术和框架 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;Boss在一些知名企业有过较长且骨干的工作经验，受到业内人事的认可 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;Boss的学历要在博士以下，本科以上，海外学历不限（太低的不用说，博士的容易陷入做得好技术，而不好产品或者市场的问题）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;有过2~3次创业经验的最佳（多则运气不好，少则则缺乏经验）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;manage&quot;&gt;Manage（管理）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;上级能经常与自己的员工进行交流，保证成员的&lt;code&gt;政治正确&lt;/code&gt;与&lt;code&gt;精神健康&lt;/code&gt; &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;项目管理有&lt;code&gt;计划性&lt;/code&gt;，这周做什么，下周做什么，这个月做什么，项目的截止是什么 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;每半年之内能看到公司的成长 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;有可执行的&lt;code&gt;激励机制&lt;/code&gt;，而不是想当然或者不执行 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;如果不是技术研讨会，或者大的工作结点总结，时间应该控制得尽量短 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;加班要有正当的加班理由，并且应该找出加班原因，以及要有避免方法 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;与&lt;code&gt;其它一些创业公司&lt;/code&gt;有良性互动，学习的 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;teammate&quot;&gt;Teammate（成员）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;有经验丰富的同事，最好是些&lt;code&gt;业内专家&lt;/code&gt;（另一个角度证明我们做的事是有专家认可的）&lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;团队成员之间经常有交流，且交流的话题不限不工作和技术 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;团队成员身份结构简单（比如没有亲属，没有派系）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;大部分团队成员都是技术兵 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;同事当中有&lt;code&gt;Geek&lt;/code&gt;（例如开源社区大牛，国内某一行业的顶尖人才）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;同事当中有些比较有品味的人（反正我个人是没什么品味的）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;同事同龄人为主，年轻人为主 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;主流大学毕业的人为主 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;有几个妹子 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;job&quot;&gt;Job（工作内容）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不做机械重复的事情 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;提供开发工具（也许应该直说是Mac）&lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;可以放弃进度进行和&lt;code&gt;代码重构&lt;/code&gt;，及项目的&lt;code&gt;Codereview&lt;/code&gt;，保证工程质量 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;鼓励使用Google，Stackoverflow，Github和开源社区 &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;使用Git 不使用SVN &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;使用新的框架，而不使用没有人维护的老旧框架 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;自己在工作中的作品可以在经过允许的情况下开源 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;facility&quot;&gt;Facility（设备）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;稳定的网速与带宽&lt;mark&gt;8分&lt;/mark&gt;，公司最好提供VPN上外网 &lt;mark&gt;2分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;上班没有人盯和查岗（有计划按计划来就好）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;除非有重要安排，有弹性工作时间和在家的远程办公 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;一周上五天班，周六上班应该有周六的工资 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;提供多显示器 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;外设，键盘，非廉价的办公椅（程序员就粘在椅子上的，体现人文关怀）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;提供测试设备 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;基本零食 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;午餐 &lt;mark&gt;4分&lt;/mark&gt;，晚餐 &lt;mark&gt;1分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;报销学习书籍&lt;mark&gt;4分&lt;/mark&gt;，一些必要合理的&lt;code&gt;正版开发软件&lt;/code&gt; &lt;mark&gt;1分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;提供的开发工具最终奖励给员工个人（有公司可以把给员工免息贷款买车，如果工作几年后业绩后就直接免还贷的，还有类似离职开火锅店的，绝对不过分）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;有定期和不定期的团建活动（吃饭，户外，电影票）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;在正规的办公场所，而不是某个民宅里（你又不是Founder）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;project&quot;&gt;Project（项目）&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;源于创新，或情怀，或理想，而不是山寨，抄袭&lt;/code&gt; &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;项目本身能够&lt;code&gt;盈利&lt;/code&gt; &lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;创新要基于当前实力 &lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;目标用户群体是百万级别，或者当前已经有数十万稳定用户（广受众总是好的）&lt;mark&gt;5分&lt;/mark&gt;&lt;/li&gt;
  &lt;li&gt;UI设计强（移动开发，技术上的不足可以用UI来弥补）&lt;mark&gt;10分&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary(个人总结，仅供参考)&lt;/h2&gt;

&lt;p&gt;总共350分，员工主观分有40分，公司团队客观有310分。&lt;/p&gt;

&lt;p&gt;我从员工的角度上来看，大约分为以下几层：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0~100分以下的公司基本上不要呆了，尽快走人    &lt;/li&gt;
  &lt;li&gt;100~160分以下的公司最好也不要呆一年以上，团队难有技术上的进步，人员配置不会太稳定的，老板估计也不大方。没有太多的长远发展    &lt;/li&gt;
  &lt;li&gt;160~220分段，一般公司差不多都在这里，看看Boss的决心和对未来的规划，特别是自己能不能和老板合得来，多学习和借鉴一下别的公司，应该可以向上走一层  &lt;/li&gt;
  &lt;li&gt;220~260分段，则可以有相当不错的工作体验和公司前景  &lt;/li&gt;
  &lt;li&gt;260分以上就安安心心一起做事吧，能不能成事不敢说，但肯定可以结交到几个可靠的朋友（同事）和成长  &lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>9个伟大的Swift面试题(译)</title>
      <link>place_your_blog_url_here/ios/2015/03/12/9-Great%20Swift%20Interview%20Questions.html</link>
      <pubDate>12 Mar 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2015/03/12/9-Great Swift Interview Questions</guid>
      <description>&lt;h1 id=&quot;swift&quot;&gt;9个伟大的Swift面试题(译)&lt;/h1&gt;

&lt;h3 id=&quot;great-swift-interview-questionshttpwwwtoptalcomswiftinterview-questions&quot;&gt;原文:  &lt;a href=&quot;http://www.toptal.com/swift/interview-questions&quot;&gt;9 Great Swift Interview Questions&lt;/a&gt;&lt;/h3&gt;

&lt;!--结构体和枚举是值类型 类是引用类型 reference types--&gt;

&lt;h2 id=&quot;section&quot;&gt;1.&lt;/h2&gt;

&lt;p&gt;Swift定义了&lt;code&gt;AnyObject&lt;/code&gt;类型用于引用类型实例的别名，而实际上是一个协议。&lt;/p&gt;

&lt;p&gt;考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;var array = [AnyObject]()
struct Test {}
array.append(Test())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码将会提示编译错误，并提示如下信息：  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;Type &#39;Test&#39; does not conform to protocol &#39;AnyObject&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个错误明显是因为&lt;code&gt;struct结构体&lt;/code&gt;是一个值，而不是引用类型，这种类型也不会实现&lt;code&gt;AnyObject&lt;/code&gt;的协议。&lt;/p&gt;

&lt;p&gt;所以再看看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;var array = [AnyObject]()
array.append(1)
array.append(2.0)
array.append(&quot;3&quot;)
array.append([4, 5, 6])
array.append([7: &quot;7&quot;, 8: &quot;8&quot;])

struct Test {}
array.append(Test())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个数组中各种值的类型有&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;dictionary&lt;/code&gt;。所有的类型都是值类型，而不是引用类型，但都并没有报错。为什么？&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2&lt;/h2&gt;
&lt;p&gt;考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;let op1: Int = 1
let op2: UInt = 2
let op3: Double = 3.34
var result = op1 + op2 + op3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请问哪儿有错？如何更正？&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3&lt;/h2&gt;
&lt;p&gt;考虑下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;var defaults = NSUserDefaults.standardUserDefaults()
var userPref = defaults.stringForKey(&quot;userPref&quot;)!
printString(userPref)

func printString(string: String) {
    println(string)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请问哪儿有Bug，如何引起的，正确的解决方法是什么？&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;4&lt;/h2&gt;

&lt;p&gt;下面一小段代码将产生一个编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct IntStack {
  var items = [Int]()
  func add(x: Int) {
    items.append(x) // Compile time error here.
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下出错的原因，并修改。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;5&lt;/h2&gt;

&lt;p&gt;在Swift中的枚举，原始值和关联值有什么区别？&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;6&lt;/h2&gt;

&lt;p&gt;Swift中&lt;code&gt;字符串 String&lt;/code&gt;是一种结构体类型，但它并没有提供数量或者长度来计算字符串中字符的个数。但是提供了一个通用的&lt;code&gt;countElements&amp;lt;T&amp;gt;()&lt;/code&gt;方法来计算长度。当查询的&lt;code&gt;字符串String&lt;/code&gt;时，请问&lt;code&gt;countElements&lt;/code&gt;方法的时间复杂度是多少？&lt;/p&gt;

&lt;p&gt;O(1)
O(n)&lt;/p&gt;

&lt;p&gt;为什么？&lt;/p&gt;

&lt;p&gt;译者提示：不同的 Unicode 字符以及相同 Unicode 字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间。因此字符串的长度不得不通过迭代字符串中每一个字符的长度来进行计算。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;7&lt;/h2&gt;

&lt;p&gt;阅读下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;struct Planet {
    var name: String
    var distanceFromSun: Double
}

let planets = [
    Planet(name: &quot;Mercury&quot;, distanceFromSun: 0.387),
    Planet(name: &quot;Venus&quot;, distanceFromSun: 0.722),
    Planet(name: &quot;Earth&quot;, distanceFromSun: 1.0),
    Planet(name: &quot;Mars&quot;, distanceFromSun: 1.52),
    Planet(name: &quot;Jupiter&quot;, distanceFromSun: 5.20),
    Planet(name: &quot;Saturn&quot;, distanceFromSun: 9.58),
    Planet(name: &quot;Uranus&quot;, distanceFromSun: 19.2),
    Planet(name: &quot;Neptune&quot;, distanceFromSun: 30.1)
]

let result1 = planets.map { $0.name }
let result2 = planets.reduce(0) { $0 + $1.distanceFromSun }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;result1&lt;/code&gt;和&lt;code&gt;result2&lt;/code&gt;常量的类型、结果分别是什么，解释一下&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;8&lt;/h2&gt;

&lt;p&gt;阅读下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;var array1 = [1, 2, 3, 4, 5]
var array2 = array1
array2.append(6)
var len = array1.count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;len&lt;/code&gt;的值是多少，为什么?&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;9&lt;/h2&gt;

&lt;p&gt;阅读下面的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class Master {
    lazy var detail: Detail = Detail(master: self)
    
    init() {
        println(&quot;Master init&quot;)
    }
    
    deinit {
        println(&quot;Master deinit&quot;)
    }
}

class Detail {
    var master: Master
    
    init(master: Master) {
        println(&quot;Detail init&quot;)
        self.master = master
    }
    
    deinit {
        println(&quot;Detail deinit&quot;)
    }
}

func createMaster() {
    var master: Master = Master()
    var detail = master.detail
}
    
createMaster()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请指出代码中的错误，并更正。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>as!操作符（译）</title>
      <link>place_your_blog_url_here/ios/2015/03/11/as!-Operator.html</link>
      <pubDate>11 Mar 2015</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2015/03/11/as!-Operator</guid>
      <description>&lt;h3 id=&quot;as&quot;&gt;as!操作符&lt;/h3&gt;

&lt;p&gt;PS1:试译一些Swift的相关内容&lt;/p&gt;

&lt;p&gt;PS2:Swift官网微博原文  &lt;a href=&quot;https://developer.apple.com/swift/blog/?id=23&quot;&gt;The as! Operator&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在Swift 1.2版之前，根据表达式的类型和被转换表达式的类型，&lt;code&gt;as&lt;/code&gt;操作符可以用于两种不同的转换&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;保守转换&lt;/strong&gt;，这种是可以通过Swift的编辑器进行检查校正。举个例子，向上类型转换（将类转换为其父类）或者指定字面量表达式（&lt;code&gt;1 as Float&lt;/code&gt;）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;强制转换&lt;/strong&gt;，这种类型转换的安全性不能得到Swift编辑器的保证，可能产生在运行时的陷阱。比如类型的向下转换，将父类转换为子类。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Swift 1.2版中，将强制转换和保守转换分成了两种不同的操作符。保守转换继续使用&lt;code&gt;as&lt;/code&gt;操作符，但强制转换使用&lt;code&gt;as!&lt;/code&gt;操作符。&lt;code&gt;!&lt;/code&gt;用于指示转换可能失败。这样一来，你一眼就可以发现它的转换可能会导致程序崩溃。&lt;/p&gt;

&lt;p&gt;下面的例子展示了这种变化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class Animal {}
class Dog: Animal {}

let a: Animal = Dog()
a as Dog		// 将提示错&quot;&#39;Animal is not convertible to &#39;Dog&#39;; did you mean to use &#39;as!&#39; to force downcast?&quot;
a as! Dog		// 这种强制向下转换是允许的

let d = Dog()
d as Animal		// 向上转换是允许的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意对比&lt;code&gt;!&lt;/code&gt;和&lt;code&gt;?&lt;/code&gt;这两种不同后缀的表达式和&lt;code&gt;as!&lt;/code&gt;与&lt;code&gt;as?&lt;/code&gt;这两种转换操作符：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-swift&quot;&gt;class Animal {}

class Cat: Animal {}

class Dog: Animal {
	var name = &quot;Spot&quot;
}

let dog: Dog? = nil
dog?.name		// 等于nil
dog!.name		// 引发运行时错误

let animal: Animal = Cat()
animal as? Dog	// 等于nil
animal as! Dog	// 引发运行时错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最简单记住这些操作符的方法可能是: &lt;code&gt;!&lt;/code&gt;意味着这可能是个陷阱， 而&lt;code&gt;?&lt;/code&gt; 意味着这可能是空值&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>创建Objective-C数据模型的心得1</title>
      <link>place_your_blog_url_here/ios/2014/12/21/SubClass-Of-%20NSObject.html</link>
      <pubDate>21 Dec 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2014/12/21/SubClass-Of- NSObject</guid>
      <description>&lt;p&gt;之前自己在公司写iOS应用主要是写的逻辑层与数据层，也算有些心得。所以决定在最近几篇Blog里将一些网上不常见的方法总结一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本期的一个关键方法&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;-(BOOL)isEqual:(id)object;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic数据模型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Basic.h&lt;/code&gt;定义了 &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index: 数据模型在App中的唯一ID  &lt;/li&gt;
  &lt;li&gt;content: 数据模型装载的内容，用于显示  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface Basic : NSObject

@property (assign) NSInteger index;
@property (copy, nonatomic) NSString *content;

- (instancetype)initWithIndex:(NSInteger)index andContent:(NSString *)content;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Basic.m&lt;/code&gt;中实现初始化方法&lt;code&gt;-initWithIndex:andContent;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@implementation Basic
- (instancetype)initWithIndex:(NSInteger)index andContent:(NSString *)content {
  if (self = [super init]) {
    _index = index;
    _content = content;
  }
  return self;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内存比较&lt;/h3&gt;

&lt;p&gt;常用的逻辑判断中，经常会使用到类似于数据库的&lt;code&gt;插入&lt;/code&gt;、&lt;code&gt;删除&lt;/code&gt;、&lt;code&gt;查找&lt;/code&gt;这几个方法。
这些方法的关键则是对&lt;strong&gt;两个数据模型的比较结果&lt;/strong&gt;，比如NSMutableArray中使用的排序方法
&amp;gt;&lt;code&gt;- (void)sortUsingComparator:(NSComparator)cmptr;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其关键点就是对&lt;code&gt;NSComparator&lt;/code&gt; Block的实现，定义如下：
&amp;gt;&lt;code&gt;typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);&lt;/code&gt;
返回两个对象的&lt;code&gt;关系&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;NSObject中定义的&lt;code&gt;- (BOOL)isEqual:(id)object;&lt;/code&gt;就是对Objective-C中，对象内存地址的判断，如果两个对象所指向的地址相同，则判断为同一对象。在下面的代码中，我先创建了一组Basic对象数据，并且将index=2的对象赋值到了&lt;code&gt;preBasicObj2&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  NSMutableArray *basics = [NSMutableArray array];
  Basic *preBasicObj2 = nil;
  for (NSInteger i = 0 ; i &amp;lt; 5 ; i++) {
    Basic *basic = [[Basic alloc]initWithIndex:i andContent:@&quot;Temp&quot;];
    [basics addObject:basic];
    if (i == 2) {
      preBasicObj2 = basic;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，再从数组中拿到index=2的对象跟&lt;code&gt;preBasicObj2&lt;/code&gt;进行一系列的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  Basic *arrayObj2 = basics[2];
  BOOL equalResult = [preBasicObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:preBasicObj2];
  NSInteger index = [basics indexOfObject:preBasicObj2];
  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理所当然的从console中输出以下结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;equalResult:1&lt;br /&gt;
containResult:1&lt;br /&gt;
index:2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;对象比较1&lt;/h3&gt;

&lt;p&gt;不过在实际开发中，我们拿到的对象可能不只是在内存中操作，仅使用内存比较是不够的。同样一个对象可以由多个地方生成，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入&lt;/li&gt;
  &lt;li&gt;网络返回&lt;/li&gt;
  &lt;li&gt;数据库读取&lt;/li&gt;
  &lt;li&gt;Copy方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的测试方法中，我重新创建了index==2的数据对象用于模拟从其它地方读取或者生成的情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  Basic *buildObj2 = [[Basic alloc]initWithIndex:2 andContent:@&quot;Temp&quot;];
  BOOL equalResult = [buildObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:buildObj2];
  NSInteger index = [basics indexOfObject:buildObj2];

  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);
        
//Output:
//equalResult:0
//containResult:0
//index:9223372036854775807
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果则如上所示，&lt;strong&gt;不相等&lt;/strong&gt;，&lt;strong&gt;不存在&lt;/strong&gt;，和&lt;strong&gt;找不到&lt;/strong&gt;。所以曾经在相当长的一段时间里，都会使用&lt;code&gt;for循环&lt;/code&gt;来进行判断。后来，我一般会改用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查找DEMO&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  __block NSInteger index2 = NSNotFound;
  [basics enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Basic *tempObj = (Basic *)obj;
    if (tempObj.index == buildObj2.index) {
      *stop = YES;
      index2 = idx;
    }
  }];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;basic-1&quot;&gt;Basic数据模型“改”&lt;/h2&gt;

&lt;p&gt;直至后来有一次偶然覆写了&lt;code&gt;NSObject&lt;/code&gt;中的&lt;code&gt;-isEqual:&lt;/code&gt;方法。此方法覆写的关键在于你需要知道你的数据模型里，哪一个是可以用于&lt;strong&gt;判断的关键属性&lt;/strong&gt;，类似于数据库中的&lt;code&gt;PRIMARY KEY&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;将下列代码添加于&lt;code&gt;Basic.m&lt;/code&gt;中。&lt;br /&gt;
在&lt;code&gt;-isEqual:&lt;/code&gt;具体实现中，还可以通过&lt;code&gt;==&lt;/code&gt;来判断是否是同一地址和&lt;code&gt;isKindOfClass&lt;/code&gt;判断是否是同一类型的数据模型来增加一些必要的限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if (![object isKindOfClass:[self class]]) {
    return NO;
  }
  Basic *inputObject = (Basic *)object;
  if (inputObject.index == self.index) {
    return YES;
  }
  return NO;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;对象比较2&lt;/h3&gt;

&lt;p&gt;然后我们重新做一下不同来源的数组对象比较测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-obj&quot;&gt;  Basic *buildObj2 = [[Basic alloc]initWithIndex:2 andContent:@&quot;Temp&quot;];
  BOOL equalResult = [buildObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:buildObj2];
  NSInteger index = [basics indexOfObject:buildObj2];

  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);

//Output:
//equalResult:1
//containResult:1
//index:2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;分析数据模型中的关键属性，找到其中的&lt;strong&gt;唯一&lt;/strong&gt;的属性用于实现&lt;code&gt;-isEqual: &lt;/code&gt;的方法。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;-isEqual:&lt;/code&gt;方法的实现可以强化很多&lt;code&gt;集合&lt;/code&gt;类对象中对于&lt;strong&gt;对象存在&lt;/strong&gt;的问题进行强化。&lt;/p&gt;

&lt;p&gt;可以参考自己数据库中的主键，网络服务返回回来的UID等&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重置iOS App请求推送授权请求</title>
      <link>place_your_blog_url_here/ios/2014/12/12/iOS%20Push%20Authoarztion%20Rest-CN.html</link>
      <pubDate>12 Dec 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2014/12/12/iOS Push Authoarztion Rest-CN</guid>
      <description>&lt;p&gt;在iOS上给自己的App创建推送通并不容易，连测试用户给App进行授权推送通知也是件很麻烦的事情。这将直接关系到用户体验与应用流程的处理。&lt;/p&gt;

&lt;p&gt;之前一直是有在模拟器上测试授权（比如通讯录，月历访问等），通过模拟器的&lt;code&gt;Reset Content and Setting&lt;/code&gt;来重置整个模拟器系统来进行调试。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/e2bf38e87f0c194df27a897c9f945f257bcf83b5/_postsImages/2014/12/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相比其它授权，Push Token是不能只使用模拟器进行测试的，因为iOS的服务器是不会给模拟器下发Push Token的。所以这个流程最好是用真机进行测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/e2bf38e87f0c194df27a897c9f945f257bcf83b5/_postsImages/2014/12/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但如果使用真机进行反复测试，在之前几乎只有一个办法:  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;通用&lt;/code&gt;-&amp;gt;&lt;code&gt;还原&lt;/code&gt;-&amp;gt;&lt;code&gt;抹掉所有内容和设置&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;清空所有内容不说，整个过程可能还长达数十分钟。&lt;/p&gt;

&lt;p&gt;昨天在和同事感叹这个问题的时候，搜索了一下stackoverflow.com上找到了答案：&lt;/p&gt;

&lt;p&gt;http://stackoverflow.com/questions/2438400/reset-push-notification-settings-for-app&lt;/p&gt;

&lt;p&gt;以及此答案指向的Apple官方解答：&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/library/ios/technotes/tn2010/tn2265.html&lt;/p&gt;

&lt;p&gt;相关文档引用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;resetting-the-push-notifications-permissions-alert-on-ios&quot;&gt;Resetting the Push Notifications Permissions Alert on iOS&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The first time a push-enabled app registers for push notifications, iOS asks the user if they wish to receive notifications for that app. Once the user has responded to this alert it is not presented again unless the device is restored or the app has been uninstalled for at least a day.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want to simulate a first-time run of your app, you can leave the app uninstalled for a day. You can achieve the latter without actually waiting a day by following these steps:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Delete your app from the device.&lt;/li&gt;
    &lt;li&gt;Turn the device off completely and turn it back on.&lt;/li&gt;
    &lt;li&gt;Go to Settings &amp;gt; General &amp;gt; Date &amp;amp; Time and set the date ahead a day or more.&lt;/li&gt;
    &lt;li&gt;Turn the device off completely again and turn it back on.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译一下：&lt;/p&gt;

&lt;p&gt;将App从设备上删除&lt;br /&gt;
将设备完全关机再重新启动&lt;br /&gt;
打开 设置-&amp;gt;通用-&amp;gt;日期与时间里 将设备时间拔快一天以上&lt;br /&gt;
将设备再次完全关机再重新启动&lt;/p&gt;

&lt;p&gt;此时再安装你的App可以像纯新的流程一样进行测试所有授权，&lt;/p&gt;

&lt;p&gt;在设置中查看你的App授权选项也是全部重置。&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;p&gt;由于之前没有仔细看过相关文档，但可以肯定iOS的授权设置会在设备重新启动时进行更新，而重置的周期需要在一天以上。以后再看到更细的说明再补充。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golden Path</title>
      <link>place_your_blog_url_here/ios/2014/12/12/Golden%20Path%20Cn.html</link>
      <pubDate>12 Dec 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2014/12/12/Golden Path Cn</guid>
      <description>&lt;h3 id=&quot;section&quot;&gt;起源&lt;/h3&gt;

&lt;p&gt;上个月的时候，公司要我整理一份iOS的代码规范给大家一起学习和使用。当然自己整理是不太可能的，所以找了一份靠谱的并且自己详细阅读与注释后给大家进行了分享。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;其中有一个章节的内容从分享那一天之后深刻的影响了。此章节很短，所以我直接粘贴在下面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/814f41347a8c6d711b04df58d0a40ae6f7d979ee/_postsImages/2014/12/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Golden Path, 非常好听名字。初次阅读此代码规范的时候我倒也没有太在意，想着只是有个好听的名字就花了三分钟到了下一章节。等到再和公司一有经验的同事一起商量的时候觉得这不仅仅是一个代码规范，更是写出好代码的Golden Key。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简单的理念与规则&lt;/h3&gt;

&lt;p&gt;如果你的代码开始处离你的左侧边框越来越远，整个代码像&lt;code&gt;&amp;gt;&lt;/code&gt;变得越来越深的时候，就会像一个&lt;strong&gt;深坑&lt;/strong&gt;一样散发出坏代码的气味。而好代码的应该是更倾向于&lt;code&gt;]&lt;/code&gt;这种形状的。&lt;/p&gt;

&lt;p&gt;当然，经过一个多月的执行与演化，我个人深化之后总结如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每一个方法内，只处理一件最重要的事情&lt;code&gt;most important thing&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;将与这个&lt;code&gt;most important thing&lt;/code&gt;关系不紧密的部分，提炼成为一个或者多个独立方法进行引用，或者作为执行&lt;code&gt;most important thing&lt;/code&gt;的条件；&lt;/li&gt;
  &lt;li&gt;将执行此方法的判断条件放在前面，排除掉所有不能执行此方法的情况，最后执行&lt;code&gt;something important &lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;多个return的返回是可以接受的。当然，是做为不执行此方法的返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;举一个实例&lt;/h3&gt;

&lt;p&gt;这是逻辑处理层对于UI与数据库建立搜索联系的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)searchContactByEmail:(NSString *email)email withCallback:(void (^)(ContactData *contact))callback{	
	if (emai.length&amp;gt;0 &amp;amp;&amp;amp; [emall rangeOfString:@&quot;@&quot;].length &amp;gt; 0 ) {//1、判断查询的email有效性
		if (self.sharedDB) {//2、判断数据库存在
			ContactData *result =  [self.sharedDB getContactByEmail:email];//3、数据库中查询联系人
			if (callback) {//4、判断回调是否存在
                    callback(result);//5、进行回调
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据之前描述，如此一个简单的方法在&lt;code&gt;callback(result);//5、进行回调 &lt;/code&gt;处已经处于至少5个&lt;code&gt;Tab&lt;/code&gt;的位置，20个&lt;code&gt;Space&lt;/code&gt;的深度，感观上就非常差。逻辑判断也相互嵌套，重点位置不明确。&lt;/p&gt;

&lt;p&gt;详细分析原代码：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;联系人email的有效性判断独立成方法&lt;code&gt;- (BOOL)checkEmailAvailable:(NSString *)email &lt;/code&gt;，这样如果需要改进判断email有效性比如添加正则匹配的时候只用修改此一；&lt;/li&gt;
  &lt;li&gt;判断数据库是否存在应该判断优先级比判断email方法高；&lt;/li&gt;
  &lt;li&gt;在数据库中查询联系人应该是这个方法最重要的一步，应该将其放在此方法靠后的位置；&lt;/li&gt;
  &lt;li&gt;回调方法应该是整个方法运行的前提条件，如果都不需要进行回调返回，那整个方法都不需要运行。&lt;/li&gt;
  &lt;li&gt;回调的位置在最后不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过整理后，代码应该至少是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)searchContactByEmail:(NSString *email)email withCallback:(void (^)(ContactData *contact))callback{
	if (!callback) {
		return;
	}
	if (!self.sharedDB) {
		return;
	}
	if (![self checkEmailAvailable:email]) {
		return;
	}
	ContactData *result = [self.sharedDB getContactByEmail:email];
	callback(result);
}

- (BOOL)checkEmailAvailable:(NSString *)email {
	if (!email.length) {
		return NO;
	}
	if (![email rangeOfString:@&quot;@&quot;].length) {
		return NO;
	}
	return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ios&quot;&gt;再补充一点我个人在iOS开发上的理解：&lt;/h3&gt;

&lt;p&gt;一般的移动客户端上基本上也就是UI调用，逻辑运算，流程控制，网络请求访问等，那么就可以将每一个方法尽可能写得简单，也起到每一个方法注释了一部分的功能 。在引用起来起到方法既是注释的作用。&lt;/p&gt;

&lt;p&gt;我自己之前见过一定要用到if大量嵌套的也就是一些算法，比如快速排序，冒泡排序等，或者是图片渲染，AI计算等有大量不可避免的条件判断。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>raywenderlich.com Objective-C代码规范中文简易注释</title>
      <link>place_your_blog_url_here/ios/2014/11/10/Raywenderlich-Objective-C-style-guide-CN.html</link>
      <pubDate>10 Nov 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ios/2014/11/10/Raywenderlich-Objective-C-style-guide-CN</guid>
      <description>&lt;h1 id=&quot;the-official-raywenderlichcom-objective-c-style-guide&quot;&gt;The official raywenderlich.com Objective-C style guide.&lt;/h1&gt;

&lt;p&gt;This style guide outlines the coding conventions for raywenderlich.com.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这份代码规范由&lt;a href=&quot;raywenderlich.com&quot;&gt;raywenderlich.com&lt;/a&gt;编写，原文&lt;a href=&quot;https://github.com/raywenderlich/objective-c-style-guide&quot;&gt;Git&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;中文注释部分由 &lt;a href=&quot;http://wing-of-war.github.io/&quot;&gt;wing.of.war.1980th@gmail&lt;/a&gt; 编写于段落的加重部分;&lt;/li&gt;
  &lt;li&gt;中文主要是对代码规范要点解释，部分为补充说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The reason we made this style guide was so that we could keep the code in our books, tutorials, and starter kits nice and consistent - even though we have many different authors working on the books.&lt;/p&gt;

&lt;p&gt;This style guide is different from other Objective-C style guides you may see, because the focus is centered on readability for print and the web. Many of the decisions were made with an eye toward conserving space for print, easy legibility, and tutorial writing.&lt;/p&gt;

&lt;h2 id=&quot;credits-&quot;&gt;Credits 编写名单&lt;/h2&gt;

&lt;p&gt;The creation of this style guide was a collaborative effort from various raywenderlich.com team members under the direction of Nicholas Waynik.  The team includes: &lt;a href=&quot;https://github.com/moayes&quot;&gt;Soheil Moayedi Azarpour&lt;/a&gt;, &lt;a href=&quot;https://github.com/ricardo-rendoncepeda&quot;&gt;Ricardo Rendon Cepeda&lt;/a&gt;, &lt;a href=&quot;https://github.com/tdahbura&quot;&gt;Tony Dahbura&lt;/a&gt;, &lt;a href=&quot;https://github.com/ColinEberhardt&quot;&gt;Colin Eberhardt&lt;/a&gt;, &lt;a href=&quot;https://github.com/mattjgalloway&quot;&gt;Matt Galloway&lt;/a&gt;, &lt;a href=&quot;https://github.com/gregheo&quot;&gt;Greg Heo&lt;/a&gt;, &lt;a href=&quot;https://github.com/hollance&quot;&gt;Matthijs Hollemans&lt;/a&gt;, &lt;a href=&quot;https://github.com/elephantronic&quot;&gt;Christopher LaPollo&lt;/a&gt;, &lt;a href=&quot;https://github.com/casademora&quot;&gt;Saul Mora&lt;/a&gt;, &lt;a href=&quot;https://github.com/macandyp&quot;&gt;Andy Pereira&lt;/a&gt;, &lt;a href=&quot;https://github.com/micpringle&quot;&gt;Mic Pringle&lt;/a&gt;, &lt;a href=&quot;https://github.com/pietrorea&quot;&gt;Pietro Rea&lt;/a&gt;, &lt;a href=&quot;https://github.com/funkyboy&quot;&gt;Cesare Rocchi&lt;/a&gt;, &lt;a href=&quot;https://github.com/icanzilb&quot;&gt;Marin Todorov&lt;/a&gt;, &lt;a href=&quot;https://github.com/ndubbs&quot;&gt;Nicholas Waynik&lt;/a&gt;, and &lt;a href=&quot;https://github.com/raywenderlich&quot;&gt;Ray Wenderlich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We would like to thank the creators of the &lt;a href=&quot;https://github.com/NYTimes/objective-c-style-guide&quot;&gt;New York Times&lt;/a&gt; and &lt;a href=&quot;https://github.com/RobotsAndPencils/objective-c-style-guide&quot;&gt;Robots &amp;amp; Pencils’&lt;/a&gt; Objective-C Style Guides.  These two style guides provided a solid starting point for this guide to be created and based upon.&lt;/p&gt;

&lt;h2 id=&quot;background-&quot;&gt;Background 参考&lt;/h2&gt;

&lt;p&gt;Here are some of the documents from Apple that informed the style guide. If something isn’t mentioned here, it’s probably covered in great detail in one of these:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html&quot;&gt;The Objective-C Programming Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html&quot;&gt;Cocoa Fundamentals Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html&quot;&gt;Coding Guidelines for Cocoa&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html&quot;&gt;iOS App Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#language&quot;&gt;Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#code-organization&quot;&gt;Code Organization&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spacing&quot;&gt;Spacing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#naming&quot;&gt;Naming&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#underscores&quot;&gt;Underscores&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#methods&quot;&gt;Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#variables&quot;&gt;Variables&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#property-attributes&quot;&gt;Property Attributes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dot-notation-syntax&quot;&gt;Dot-Notation Syntax&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#literals&quot;&gt;Literals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#constants&quot;&gt;Constants&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enumerated-types&quot;&gt;Enumerated Types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#case-statements&quot;&gt;Case Statements&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#private-properties&quot;&gt;Private Properties&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#booleans&quot;&gt;Booleans&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conditionals&quot;&gt;Conditionals&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ternary-operator&quot;&gt;Ternary Operator&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#init-methods&quot;&gt;Init Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cgrect-functions&quot;&gt;CGRect Functions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#golden-path&quot;&gt;Golden Path&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#error-handling&quot;&gt;Error handling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#singletons&quot;&gt;Singletons&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#line-breaks&quot;&gt;Line Breaks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#smiley-face&quot;&gt;Smiley Face&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xcode-project&quot;&gt;Xcode Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;language&quot;&gt;Language&lt;/h2&gt;

&lt;p&gt;US English should be used.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用美式英语和单词拼写，见过用法语和日语拼音的变量，识别困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIColor *myColor = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIColor *myColour = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;code-organization-&quot;&gt;Code Organization 代码组织&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;#pragma mark -&lt;/code&gt; to categorize methods in functional groupings and protocol/delegate implementations following this general structure.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;#pragma mark -&lt;/code&gt; 把相同功能的代码放入同一代码区中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保持&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;文件内的代码分块一致与顺序一致。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;#pragma mark - Lifecycle

- (instancetype)init {...}

- (void)dealloc {...}

- (void)viewDidLoad {...}

- (void)viewWillAppear:(BOOL)animated {...}

- (void)didReceiveMemoryWarning {...}

#pragma mark - Custom Accessors

- (void)setCustomProperty:(id)value {...}

- (id)customProperty {...}

#pragma mark - IBActions

- (IBAction)submitData:(id)sender {...}

#pragma mark - Public

- (void)publicMethod {...}

#pragma mark - Private

- (void)privateMethod {...}

#pragma mark - Protocol conformance
#pragma mark - UITextFieldDelegate
#pragma mark - UITableViewDataSource
#pragma mark - UITableViewDelegate

#pragma mark - NSCopying

- (id)copyWithZone:(NSZone *)zone {...}

#pragma mark - NSObject

- (NSString *)description {...}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;额外：如果有次级分组，使用 &lt;code&gt;#pragma mark &lt;/code&gt;划分子代码区。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;
#pragma mark - Main Func

- (void)sync;

#pragma mark Add

- (void)add:(id)obj;
- (void)adds:(NSArray *)objs;

#pragma mark Update

- (void)update:(id)obj;
- (void)update:(NSArray *)objs;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;spacing&quot;&gt;Spacing空格&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Indent using 2 spaces (this conserves space in print and makes line wrapping less likely). Never indent with tabs. Be sure to set this preference in Xcode.
    &lt;ul&gt;
      &lt;li&gt;XCODE默认换行是4个空格，推 荐使用2个空格，让代码看起来更紧凑，&lt;/li&gt;
      &lt;li&gt;设置方法:&lt;code&gt;xcode&lt;/code&gt;-&amp;gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;Text Editing&lt;/code&gt;-&amp;gt;&lt;code&gt;Indentation&lt;/code&gt;-&amp;gt;&lt;code&gt;Indent width&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Method braces and other braces (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; etc.) always open on the same line as the statement but close on a new line.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;* 方法体`{}`的开始`{`与方法和`if`/`else`/`switch`/`while`控制流方法处于同一行，`}`则需要另起一行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (user.isHappy) {
  //Do something
} else {
  //Do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (user.isHappy)
{
    //Do something
}
else {
    //Do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;There should be exactly one blank line between methods to aid in visual clarity and organization. Whitespace within methods should separate functionality, but often there should probably be new methods.
    &lt;ul&gt;
      &lt;li&gt;方法之间应该保持一个空行，有助于保持清晰的结构。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prefer using auto-synthesis. But if necessary, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic&lt;/code&gt; should each be declared on new lines in the implementation.
    &lt;ul&gt;
      &lt;li&gt;推荐使用&lt;code&gt;auto-property-synthesis&lt;/code&gt;自动生成属性的Set,Get方法；&lt;/li&gt;
      &lt;li&gt;如果需要，每一个&lt;code&gt;@synthesize&lt;/code&gt; 和 &lt;code&gt;@dynamic&lt;/code&gt;都应该独占一行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Colon-aligning method invocation should often be avoided.  There are cases where a method signature may have &amp;gt;= 3 colons and colon-aligning makes the code more readable. Please do &lt;strong&gt;NOT&lt;/strong&gt; however colon align methods containing blocks because Xcode’s indenting makes it illegible.
    &lt;ul&gt;
      &lt;li&gt;多个回调模块，使用&lt;code&gt;{}&lt;/code&gt;括号的对齐比使用 方法名中的&lt;code&gt;:&lt;/code&gt;对齐要便于阅读。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;// blocks are easily readable
[UIView animateWithDuration:1.0 animations:^{
  // something
} completion:^(BOOL finished) {
  // something
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;// colon-aligning makes the block indentation hard to read
// 冒号对齐让block模块缩进难以阅读

[UIView animateWithDuration:1.0
                 animations:^{
                     // something
                 }
                 completion:^(BOOL finished) {
                     // something
                 }];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;comments&quot;&gt;Comments&lt;/h2&gt;

&lt;p&gt;When they are needed, comments should be used to explain &lt;strong&gt;why&lt;/strong&gt; a particular piece of code does something. Any comments that are used must be kept up-to-date or deleted.&lt;/p&gt;

&lt;p&gt;Block comments should generally be avoided, as code should be as self-documenting as possible, with only the need for intermittent, few-line explanations. &lt;em&gt;Exception: This does not apply to those comments used to generate documentation.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注释及时更新，或者直接删除；&lt;/li&gt;
  &lt;li&gt;只有在复杂的地方才需要；&lt;/li&gt;
  &lt;li&gt;代码如注释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;naming-&quot;&gt;Naming 命名&lt;/h2&gt;

&lt;p&gt;Apple naming conventions should be adhered to wherever possible, especially those related to &lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html&quot;&gt;memory management rules&lt;/a&gt; (&lt;a href=&quot;http://stackoverflow.com/a/2865194/340508&quot;&gt;NARC&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Long, descriptive method and variable names are good.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;鼓励使用完整，并且有描述性的变量名和方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIButton *settingsButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIButton *setBut;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A three letter prefix should always be used for class names and constants, however may be omitted for Core Data entity names. For any official raywenderlich.com books, starter kits, or tutorials, the prefix ‘RWT’ should be used.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三个首字母的缩写仅用于类名和常量之中。（并且大写）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Constants should be camel-case with all words capitalized and prefixed by the related class name for clarity.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;驼峰命名。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSTimeInterval const fadetime = 1.7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Properties should be camel-case with the leading word being lowercase. Use auto-synthesis for properties rather than manual @synthesize statements unless you have good reason.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果充分的理由，使用自动变量赋值方法，而不是自己实现&lt;code&gt;@synthesize&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (strong, nonatomic) NSString *descriptiveVariableName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;id varnm;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;underscores&quot;&gt;Underscores&lt;/h3&gt;

&lt;p&gt;When using properties, instance variables should always be accessed and mutated using &lt;code&gt;self.&lt;/code&gt;. This means that all properties will be visually distinct, as they will all be prefaced with &lt;code&gt;self.&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;An exception to this: inside initializers, the backing instance variable (i.e. _variableName) should be used directly to avoid any potential side effects of the getters/setters.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了init初始化方法中使用&lt;code&gt;_variableName&lt;/code&gt;来获取或者设置值之外，都应该使用&lt;code&gt;self.&lt;/code&gt;来获取变量，实例中的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Local variables should not contain underscores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本地变量不应该包含下划线。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;methods&quot;&gt;Methods&lt;/h2&gt;

&lt;p&gt;In method signatures, there should be a space after the method type (-/+ symbol). &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法名和方法类型&lt;code&gt;（-/+）&lt;/code&gt;之间有一个空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There should be a space between the method segments (matching Apple’s style). &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法片段间有空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Always include a keyword and be descriptive with the word before the argument which describes the argument.&lt;/p&gt;

&lt;p&gt;The usage of the word “and” is reserved.  It should not be used for multiple parameters as illustrated in the &lt;code&gt;initWithWidth:height:&lt;/code&gt; example below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多个参数名前的方法要有描述性的关键字,并且不要包含&lt;strong&gt;and&lt;/strong&gt;字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)setExampleText:(NSString *)text image:(UIImage *)image;
- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;-(void)setT:(NSString *)text i:(UIImage *)image;
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
- (instancetype)initWith:(int)width and:(int)height;  // Never do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Particular：参数名在方法的最后&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (id)viewWithTag:(NSInteger)tag;
//Not Preferred
- (id)taggedView:(NSInteger)tag;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;variables&quot;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Variables should be named as descriptively as possible. Single letter variable names should be avoided except in &lt;code&gt;for()&lt;/code&gt; loops.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了在流控制方法中的临时变量，变量名应该是有一定描述性的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Asterisks indicating pointers belong with the variable, e.g., &lt;code&gt;NSString *text&lt;/code&gt; not &lt;code&gt;NSString* text&lt;/code&gt; or &lt;code&gt;NSString * text&lt;/code&gt;, except in the case of constants.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;*&lt;/code&gt;与变量名紧靠在一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;#private-properties&quot;&gt;Private properties&lt;/a&gt; should be used in place of instance variables whenever possible. Although using instance variables is a valid way of doing things, by agreeing to prefer properties our code will be more consistent. &lt;/p&gt;

&lt;p&gt;Direct access to instance variables that ‘back’ properties should be avoided except in initializer methods (&lt;code&gt;init&lt;/code&gt;, &lt;code&gt;initWithCoder:&lt;/code&gt;, etc…), &lt;code&gt;dealloc&lt;/code&gt; methods and within custom setters and getters. For more information on using Accessor Methods in Initializer Methods and dealloc, see &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除&lt;code&gt;init&lt;/code&gt;,&lt;code&gt;dealloc&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;,&lt;code&gt;get&lt;/code&gt;等此类方法，应该尽量使用&lt;code&gt;setters&lt;/code&gt;和&lt;code&gt;getters&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTTutorial : NSObject

@property (strong, nonatomic) NSString *tutorialName;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTTutorial : NSObject {
  NSString *tutorialName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;property-attributes&quot;&gt;Property Attributes&lt;/h2&gt;

&lt;p&gt;Property attributes should be explicitly listed, and will help new programmers when reading the code.  The order of properties should be storage then atomicity, which is consistent with automatically generated code when connecting UI elements from Interface Builder.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量申明时，原子属性在存储之后。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (weak, nonatomic) IBOutlet UIView *containerView;
@property (strong, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Properties with mutable counterparts (e.g. NSString) should prefer &lt;code&gt;copy&lt;/code&gt; instead of &lt;code&gt;strong&lt;/code&gt;. 
Why? Even if you declared a property as &lt;code&gt;NSString&lt;/code&gt; somebody might pass in an instance of an &lt;code&gt;NSMutableString&lt;/code&gt; and then change it without you noticing that.  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;经常变更的变量更倾向于使用&lt;code&gt;copy&lt;/code&gt;，而不是&lt;code&gt;strong&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (copy, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (strong, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;以下引用&lt;a href=&quot;http://blog.csdn.net/itianyi/article/details/9018567&quot;&gt;NSString什么时候用copy，什么时候用strong&lt;/a&gt;对此例进行说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (retain,nonatomic) NSString *rStr;
@property (copy, nonatomic)   NSString *cStr;

- (void)test:
{
    NSMutableString *mStr = [NSMutableStringstringWithFormat:@&quot;abc&quot;];
    self.rStr   = mStr;
    self.cStr     = mStr;
    NSLog(@&quot;mStr:%p,%p&quot;,  mStr,&amp;amp;mStr);
    NSLog(@&quot;retainStr:%p,%p&quot;, _rStr, &amp;amp;_rStr);
    NSLog(@&quot;copyStr:%p,%p&quot;,   _cStr, &amp;amp;_cStr);
｝

/*
假如，mStr对象的地址为0x11，也就是0x11是@“abc”的首地址，mStr变量自身在内存中的地址为0x123；
当把mStr赋值给retain的rStr时，rStr对象的地址为0x11，rStr变量自身在内存中的地址为0x124；rStr与mStr指向同样的地址，他们指向的是同一个对象@“abc”，这个对象的地址为0x11，所以他们的值是一样的。
当把mStr赋值给copy的cStr时，cStr对象的地址为0x22，cStr变量自身在内存中的地址0x125；cStr与mStr指向的地址是不一样的，他们指向的是不同的对象，所以copy是深复制，一个新的对象，这个对象的地址为0x22，值为@“abc”。

如果现在改变mStr的值：
    [mStr appendString:@&quot;de&quot;];
    NSLog(@&quot;retainStr:%@&quot;,  _rStr);
    NSLog(@&quot;copyStr:%@&quot;,    _cStr);

结果，
使用retain的字串rStr的值：@&quot;abcde&quot;,
而使用copy的字串cStr的值:@&quot;abc&quot;,
所以，如果一般情况下，我们都不希望字串的值跟着mStr变化，所以我们一般用copy来设置string的属性。
如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。
注意：上面的情况是针对于当把NSMutableString赋值给NSString的时候，才会有不同，如果是赋值是NSString对象，那么使用copy还是strong，结果都是一样的，因为NSString对象根本就不能改变自身的值，他是不可变的。

把一个对象赋值给一个属性变量，当这个对象变化了，如果希望属性变量变化就使用strong属性，如果希望属性变量不跟着变化，就是用copy属性。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dot-notation-syntax--&quot;&gt;Dot-Notation Syntax 点表达式 句法&lt;/h2&gt;

&lt;p&gt;Dot syntax is purely a convenient wrapper around accessor method calls. When you use dot syntax, the property is still accessed or changed using getter and setter methods.  Read more &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dot-notation should &lt;strong&gt;always&lt;/strong&gt; be used for accessing and mutating properties, as it makes code more concise. Bracket notation is preferred in all other instances.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;点表达式应该是用于获取或者改变属性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其它实例方法，都推荐使用&lt;code&gt;[]&lt;/code&gt;&lt;strong&gt;括号记法&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger arrayCount = [self.array count];
view.backgroundColor = [UIColor orangeColor];
[UIApplication sharedApplication].delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger arrayCount = self.array.count;
[view setBackgroundColor:[UIColor orangeColor]];
UIApplication.sharedApplication.delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;literals-&quot;&gt;Literals 字面量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Literals翻译成字面量或者字面值，就是直接被写到源代码中的值&lt;a href=&quot;http://my.oschina.net/iamzkt/blog/127718&quot;&gt;Objective-C 之 Literals（字面量）&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它的语法很简单，上面的代码就是通过在C字符串的前面加上@符号创建了一个NSString对象greeting，整段代码看起来简洁易懂，如果没有直接量语法，那么创建这个greeting可能就要使用下面的方法了：
~~~objc
NSString *greeting = [NSString stringWithUTF8String:”Hello World”];
~~~&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;NSString&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSArray&lt;/code&gt;, and &lt;code&gt;NSNumber&lt;/code&gt; literals should be used whenever creating immutable instances of those objects. Pay special care that &lt;code&gt;nil&lt;/code&gt; values can not be passed into &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;NSDictionary&lt;/code&gt; literals, as this will cause a crash.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];
NSDictionary *productManagers = @{@&quot;iPhone&quot;: @&quot;Kate&quot;, @&quot;iPad&quot;: @&quot;Kamal&quot;, @&quot;Mobile Web&quot;: @&quot;Bill&quot;};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingStreetNumber = @10018;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;constants-&quot;&gt;Constants 常量&lt;/h2&gt;

&lt;p&gt;Constants are preferred over in-line string literals or numbers, as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace. Constants should be declared as &lt;code&gt;static&lt;/code&gt; constants and not &lt;code&gt;#define&lt;/code&gt;s unless explicitly being used as a macro.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量使用&lt;code&gt;static&lt;/code&gt;与&lt;code&gt;const&lt;/code&gt;创建，&lt;code&gt;#define&lt;/code&gt;可以用于定义便利方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;;

static CGFloat const RWTImageThumbnailHeight = 50.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;#define CompanyName @&quot;RayWenderlich.com&quot;

#define thumbnailHeight 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;enumerated-types&quot;&gt;Enumerated Types&lt;/h2&gt;

&lt;p&gt;When using &lt;code&gt;enum&lt;/code&gt;s, it is recommended to use the new fixed underlying type specification because it has stronger type checking and code completion. The SDK now includes a macro to facilitate and encourage use of fixed underlying types: &lt;code&gt;NS_ENUM()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;推荐使用代码提示中宏定义的&lt;code&gt;NS_ENUM()&lt;/code&gt;枚举模块来创建，它可以提供更严谨的类型检测和代码补完功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;For Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) {
  RWTLeftMenuTopItemMain,
  RWTLeftMenuTopItemShows,
  RWTLeftMenuTopItemSchedule
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also make explicit value assignments (showing older k-style constant definition):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;typedef NS_ENUM(NSInteger, RWTGlobalConstants) {
  RWTPinSizeMin = 1,
  RWTPinSizeMax = 5,
  RWTPinCountMin = 100,
  RWTPinCountMax = 500,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Older k-style constant definitions should be &lt;strong&gt;avoided&lt;/strong&gt; unless writing CoreFoundation C code (unlikely).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统的枚举则让代码看起来更像C。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;enum GlobalConstants {
  kMaxPinSize = 5,
  kMaxPinCount = 500,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;case-statements-&quot;&gt;Case Statements 分支&lt;/h2&gt;

&lt;p&gt;Braces are not required for case statements, unless enforced by the complier.&lt;br /&gt;
When a case contains more than one line, braces should be added.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每一个&lt;code&gt;case&lt;/code&gt;分支下的执行语句，如果只有一行，不加&lt;code&gt;{}&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;如果&lt;code&gt;case&lt;/code&gt;分支下的执行语句有多行，则使用&lt;code&gt;{}&lt;/code&gt;划定范围。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;switch (condition) {
  case 1:
    // ...
    break;
  case 2: {
    // ...
    // Multi-line example using braces
    break;
  }
  case 3:
    // ...
    break;
  default: 
    // ...
    break;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are times when the same code can be used for multiple cases, and a fall-through should be used.  A fall-through is the removal of the ‘break’ statement for a case thus allowing the flow of execution to pass to the next case value.  A fall-through should be commented for coding clarity.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同&lt;code&gt;case&lt;/code&gt;分支的条件使用&lt;code&gt;条件继承 fall-through&lt;/code&gt;，在上层&lt;code&gt;case&lt;/code&gt;中不使用&lt;code&gt;break&lt;/code&gt;跳出，直接继承下层&lt;code&gt;case&lt;/code&gt;的执行语句。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;switch (condition) {
  case 1:
    // ** fall-through! **
  case 2:
    // code executed for values 1 and 2
    break;
  default: 
    // ...
    break;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using an enumerated type for a switch, ‘default’ is not needed.   For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;default&lt;/code&gt;条件非必需&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;

switch (menuType) {
  case RWTLeftMenuTopItemMain:
    // ...
    break;
  case RWTLeftMenuTopItemShows:
    // ...
    break;
  case RWTLeftMenuTopItemSchedule:
    // ...
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;private-properties&quot;&gt;Private Properties&lt;/h2&gt;

&lt;p&gt;Private properties should be declared in class extensions (anonymous categories) in the implementation file of a class. Named categories (such as &lt;code&gt;RWTPrivate&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;) should never be used unless extending another class.   The Anonymous category can be shared/exposed for testing using the &lt;headerfile&gt;+Private.h file naming convention.&lt;/headerfile&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;私有变更应该在类的私有类别中，不需要加&lt;code&gt;private&lt;/code&gt;等词语来进行修饰。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;私有类别可以在命名为&lt;code&gt;&amp;lt;headerfile&amp;gt;+Private.h&lt;/code&gt;的文件里提供&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;For Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTDetailViewController ()

@property (strong, nonatomic) GADBannerView *googleAdView;
@property (strong, nonatomic) ADBannerView *iAdView;
@property (strong, nonatomic) UIWebView *adXWebView;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;booleans&quot;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;Objective-C uses &lt;code&gt;YES&lt;/code&gt; and &lt;code&gt;NO&lt;/code&gt;.  Therefore &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; should only be used for CoreFoundation, C or C++ code.  Since &lt;code&gt;nil&lt;/code&gt; resolves to &lt;code&gt;NO&lt;/code&gt; it is unnecessary to compare it in conditions. &lt;/p&gt;

&lt;p&gt;Never compare something directly to &lt;code&gt;YES&lt;/code&gt;, because &lt;code&gt;YES&lt;/code&gt; is defined to 1 and a &lt;code&gt;BOOL&lt;/code&gt; can be up to 8 bits.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要把对象直接和&lt;code&gt;YES&lt;/code&gt;进行比较，&lt;/li&gt;
  &lt;li&gt;可以覆写类继承自&lt;code&gt;NSOjbect&lt;/code&gt;下的&lt;code&gt;-(BOOL)isEqual:(id)obj;&lt;/code&gt;方法来类的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This allows for more consistency across files and greater visual clarity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (someObject) {}
if (![anotherObject boolValue]) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (someObject == nil) {}
if ([anotherObject boolValue] == NO) {}
if (isAwesome == YES) {} // Never do this.
if (isAwesome == true) {} // Never do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the name of a &lt;code&gt;BOOL&lt;/code&gt; property is expressed as an adjective, the property can omit the “is” prefix but specifies the conventional name for the get accessor, for example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code&gt;BOOL&lt;/code&gt;变量是形容词，不需要&lt;strong&gt;is&lt;/strong&gt;来进行修饰。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (assign, getter=isEditable) BOOL editable;
//**Not Preferred:**
//@property (assign, getter=isEditable) BOOL isEditable;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Text and example taken from the &lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE&quot;&gt;Cocoa Naming Guidelines&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conditionals&quot;&gt;Conditionals&lt;/h2&gt;

&lt;p&gt;Conditional bodies should always use braces even when a conditional body could be written without braces (e.g., it is one line only) to prevent errors. These errors include adding a second line and expecting it to be part of the if-statement. Another, &lt;a href=&quot;http://programmers.stackexchange.com/a/16530&quot;&gt;even more dangerous defect&lt;/a&gt; may happen where the line “inside” the if-statement is commented out, and the next line unwittingly becomes part of the if-statement. In addition, this style is more consistent with all other conditionals, and therefore more easily scannable.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一定使用&lt;code&gt;{}&lt;/code&gt;来划定判断后的执行语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;即使执行语非常简单，也不能与条件判断在一行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error) {
  return success;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error)
  return success;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error) return success;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ternary-operator-&quot;&gt;Ternary Operator 三元运算符&lt;/h3&gt;

&lt;p&gt;The Ternary operator, &lt;code&gt;?:&lt;/code&gt; , should only be used when it increases clarity or code neatness. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有在确定能够促进代码整洁与清晰的前提下才使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A single condition is usually all that should be evaluated. Evaluating multiple conditions is usually more understandable as an &lt;code&gt;if&lt;/code&gt; statement, or refactored into instance variables. &lt;/p&gt;

&lt;p&gt;In general, the best use of the ternary operator is during assignment of a variable and deciding which value to use.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三元运算符最好在赋值需要判断时使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Non-boolean variables should be compared against something, and parentheses are added for improved readability.  If the variable being compared is a boolean type, then no parentheses are needed.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非BOOL类型变量必须要与其类型变量做出判断后才能使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger value = 5;
result = (value != 0) ? x : y;

BOOL isHorizontal = YES;
result = isHorizontal ? x : y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;result = a &amp;gt; b ? x = c &amp;gt; d ? c : d : y;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;init-methods&quot;&gt;Init Methods&lt;/h2&gt;

&lt;p&gt;Init methods should follow the convention provided by Apple’s generated code template.  A return type of ‘instancetype’ should also be used instead of ‘id’.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;init&lt;/code&gt;方法中返回值使用&lt;code&gt;instancetype&lt;/code&gt;取代&lt;code&gt;id&lt;/code&gt;作为返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (instancetype)init {
  self = [super init];
  if (self) {
    // ...
  }
  return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href=&quot;#class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/a&gt; for link to article on instancetype.&lt;/p&gt;

&lt;h2 id=&quot;class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/h2&gt;

&lt;p&gt;Where class constructor methods are used, these should always return type of ‘instancetype’ and never ‘id’. This ensures the compiler correctly infers the result type. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface Airplane
+ (instancetype)airplaneWithType:(RWTAirplaneType)type;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on instancetype can be found on &lt;a href=&quot;http://nshipster.com/instancetype/&quot;&gt;NSHipster.com&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以下摘取自&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/16994913&quot;&gt;Objective-C中的instancetype和id关键字&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;三、instancetype作用
1、作用
如果一个不是关联返回类型的方法，如下：

@interface NSArray  
+ (id)constructAnArray;  
@end  
当我们使用如下方式初始化NSArray时：


[NSArray constructAnArray];  
根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id。
但是如果使用instancetype作为返回类型，如下：


@interface NSArray  
+ (instancetype)constructAnArray;  
@end  
当使用相同方式初始化NSArray时：

[NSArray constructAnArray];  
得到的返回类型和方法所在类的类型相同，是NSArray*!
总结一下，instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！

2、好处
能够确定对象的类型，能够帮助编译器更好的为我们定位代码书写问题，比如：

[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; //  &quot;No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`&quot;  
  
[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error)  
上例中第一行代码，由于[[NSArray alloc]init]的结果是NSArray*，这样编译器就能够根据返回的数据类型检测出NSArray是否实现mediaPlaybackAllowsAirPlay方法。有利于开发者在编译阶段发现错误。
第二行代码，由于array不属于关联返回类型方法，[NSArray array]返回的是id类型，编译器不知道id类型的对象是否实现了mediaPlaybackAllowsAirPlay方法，也就不能够替开发者及时发现错误。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cgrect-functions&quot;&gt;CGRect Functions&lt;/h2&gt;

&lt;p&gt;When accessing the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, or &lt;code&gt;height&lt;/code&gt; of a &lt;code&gt;CGRect&lt;/code&gt;, always use the &lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html&quot;&gt;&lt;code&gt;CGGeometry&lt;/code&gt; functions&lt;/a&gt; instead of direct struct member access. From Apple’s &lt;code&gt;CGGeometry&lt;/code&gt; reference:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;CGGeometry&lt;/code&gt;方法来获取&lt;code&gt;CGRect&lt;/code&gt;结构下的长宽位置值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;CGRect frame = self.view.frame;

CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);
CGRect frame = CGRectMake(0.0, 0.0, width, height);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;CGRect frame = self.view.frame;

CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
CGRect frame = (CGRect){ .origin = CGPointZero, .size = frame.size };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;golden-path&quot;&gt;Golden Path&lt;/h2&gt;

&lt;p&gt;When coding with conditionals, the left hand margin of the code should be the “golden” or “happy” path.  That is, don’t nest &lt;code&gt;if&lt;/code&gt; statements.  Multiple return statements are OK.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;条件判断的左侧空间被称为&lt;strong&gt;黄金路径&lt;/strong&gt;或者&lt;strong&gt;幸福路径&lt;/strong&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减少&lt;code&gt;if&lt;/code&gt;的条件的嵌套，扁平化多个返回条件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数的多个返回条件是可以接受的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)someMethod {
  if (![someOther boolValue]) {
	return;
  }

  //Do something important
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)someMethod {
  if ([someOther boolValue]) {
    //Do something important
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Demo:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;    if (text.length &amp;gt; 0) {
        WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
        if (contact) {
            [_sentTo addObject:contact];
            [self setSearchTableShow:NO];
            tokenField.inputText = @&quot;&quot;;
            [tokenField reloadData];
       }
    } else {
        [_subjectTokenField becomeFirstResponder];
    }

//Rebuild:

    if (text.length &amp;lt;= 0) {
        [_subjectTokenField becomeFirstResponder];
        return;
    }
    WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
    if (!contact) {
        return;
    }
    [_sentTo addObject:contact];
    [self setSearchTableShow:NO];
    tokenField.inputText = @&quot;&quot;;
    [tokenField reloadData];

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;error-handling&quot;&gt;Error handling&lt;/h2&gt;

&lt;p&gt;When methods return an error parameter by reference, switch on the returned value, not the error variable.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件判断错误时，应该是错误变量本身。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSError *error;
if (![self trySomethingWithError:&amp;amp;error]) {
  // Handle Error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSError *error;
[self trySomethingWithError:&amp;amp;error];
if (error) {
  // Handle Error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some of Apple’s APIs write garbage values to the error parameter (if non-NULL) in successful cases, so switching on the error can cause false negatives (and subsequently crash).&lt;/p&gt;

&lt;h2 id=&quot;singletons&quot;&gt;Singletons&lt;/h2&gt;

&lt;p&gt;Singleton objects should use a thread-safe pattern for creating their shared instance.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单例必须线程安全。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;+ (instancetype)sharedInstance {
  static id sharedInstance = nil;

  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{
    sharedInstance = [[self alloc] init];
  });

  return sharedInstance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will prevent &lt;a href=&quot;http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html&quot;&gt;possible and sometimes prolific crashes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;line-breaks&quot;&gt;Line Breaks&lt;/h2&gt;

&lt;p&gt;Line breaks are an important topic since this style guide is focused for print and online readability.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A long line of code like this should be carried on to the second line adhering to this style guide’s Spacing section (two spaces).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为代码太长需要换行时，与首行有两个空格间隔；&lt;/li&gt;
  &lt;li&gt;设置方法：&lt;code&gt;xcode&lt;/code&gt;-&amp;gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;Text Editing&lt;/code&gt;-&amp;gt;&lt;code&gt;Indentation&lt;/code&gt;-&amp;gt;&lt;code&gt;Line Wrapping&lt;/code&gt; 手动设置为&lt;code&gt;2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;self.productsRequest = [[SKProductsRequest alloc] 
  initWithProductIdentifiers:productIdentifiers];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;smiley-face&quot;&gt;Smiley Face&lt;/h2&gt;

&lt;p&gt;Smiley faces are a very prominent style feature of the raywenderlich.com site!  It is very important to have the correct smile signifying the immense amount of happiness and excitement for the coding topic.  The end square bracket is used because it represents the largest smile able to be captured using ascii art.  A half-hearted smile is represented if an end parenthesis is used, and thus not preferred.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;]&lt;/code&gt;看起来比&lt;code&gt;)&lt;/code&gt;笑得更开心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;:)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xcode-project&quot;&gt;Xcode project&lt;/h2&gt;

&lt;p&gt;The physical files should be kept in sync with the Xcode project files in order to avoid file sprawl. Any Xcode groups created should be reflected by folders in the filesystem. Code should be grouped not only by type, but also by feature for greater clarity.&lt;/p&gt;

&lt;p&gt;When possible, always turn on “Treat Warnings as Errors” in the target’s Build Settings and enable as many &lt;a href=&quot;http://boredzo.org/blog/archives/2009-11-07/warnings&quot;&gt;additional warnings&lt;/a&gt; as possible. If you need to ignore a specific warning, use &lt;a href=&quot;http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas&quot;&gt;Clang’s pragma feature&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;other-objective-c-style-guides&quot;&gt;Other Objective-C Style Guides&lt;/h1&gt;

&lt;p&gt;If ours doesn’t fit your tastes, have a look at some other style guides:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/RobotsAndPencils/objective-c-style-guide&quot;&gt;Robots &amp;amp; Pencils&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/NYTimes/objective-c-style-guide&quot;&gt;New York Times&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml&quot;&gt;Google&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/github/objective-c-conventions&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://trac.adium.im/wiki/CodingStyle&quot;&gt;Adium&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/soffes/812796&quot;&gt;Sam Soffes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cocoadevcentral.com/articles/000082.php&quot;&gt;CocoaDevCentral&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html&quot;&gt;Luke Redpath&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cimgf.com/zds-code-style-guide/&quot;&gt;Marcus Zarra&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何快速的切换Mac系统的网络配置</title>
      <link>place_your_blog_url_here/other/2014/11/03/SwitchInternetSetting-CN.html</link>
      <pubDate>03 Nov 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/other/2014/11/03/SwitchInternetSetting-CN</guid>
      <description>&lt;h1 id=&quot;mac&quot;&gt;如何快速的切换Mac系统的网络配置&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;由于国内网络环境恶劣，在日常使用中，我经常会面临如下情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;访问Google, Youtube等境外网站需要使用&lt;code&gt;曲径&lt;/code&gt;等自动代理配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;或者最近经常出现的DNS服务污染，比较严重的情况连taobao搜索都不可使用，或者在使用Appstore下载更新时，使用 114, 08 , openDNS等手动配置更为靠谱&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时候却造成我访问国内网站（视频网站会比较明显）速度下降，所以需要切换回运营提供的DNS（此DNS一般能与114，08等DNS有几十到几百望毫秒的差距）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;所以每当感觉上网不畅时，一般都需要点开&lt;code&gt;系统偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;网络&lt;/code&gt;-&amp;gt;&lt;code&gt;高级&lt;/code&gt;-&amp;gt;&lt;code&gt;DNS&lt;/code&gt; or &lt;code&gt;代理&lt;/code&gt;等设置，还需要额外的从一些记录软件中提取相应的配置参数&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;系统偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;网络&lt;/code&gt; 此页面上有一个位置，选择&lt;code&gt;编辑位置&lt;/code&gt;后点击下面的&lt;code&gt;+&lt;/code&gt;，即设立一种新的网络环境。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用：&lt;/h2&gt;

&lt;p&gt;OK，此种方法最赞的就是只用点击桌面左上角的小苹果&lt;code&gt;&lt;/code&gt;-&amp;gt;&lt;code&gt;位置&lt;/code&gt;进行切换即可。
####缺点：网络会切断一会儿。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby Study Memo</title>
      <link>place_your_blog_url_here/ruby/2014/10/25/Ruby_Study-EN.html</link>
      <pubDate>25 Oct 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/ruby/2014/10/25/Ruby_Study-EN</guid>
      <description>&lt;p&gt;Leran this at www.codecademy.com. Great online course.I picked up some key word from this lession for memo.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;basic&quot;&gt;Basic&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;There’s always more than one way to do something in Ruby.&lt;/li&gt;
  &lt;li&gt;Everything in Ruby is an Object.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;input&quot;&gt;Input&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;variable = gets.chomp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;chomp&lt;/code&gt; removes that extra line.&lt;/p&gt;

&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;create with empty hash&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;file = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;need space between variable and operation&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Error: a++
Fine: a += 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;control-flow&quot;&gt;Control Flow&lt;/h2&gt;

&lt;h3 id=&quot;unless--ifvar&quot;&gt;unless == if(!var)&lt;/h3&gt;

&lt;h2 id=&quot;loops--iterators&quot;&gt;Loops &amp;amp; Iterators&lt;/h2&gt;

&lt;h3 id=&quot;until&quot;&gt;until&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 0
until i == 6
  i += 1
end
puts i
# ==&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;loop&quot;&gt;Loop&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 20
loop do
  i -= 1
  print &quot;#{i}&quot;
  break if i &amp;lt;= 0
end
#==&amp;gt;191817161514131211109876543210
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code&gt;next&lt;/code&gt; keywords can be used to skip over certain steps in the loop.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;i = 20
loop do
  i -= 1
  next if i % 2 == 1
  print &quot;#{i}&quot;
  break if i &amp;lt;= 0
end
#==&amp;gt;181614121086420
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;inclusive-and-exclusive-ranges&quot;&gt;Inclusive and Exclusive Ranges&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;1..15&lt;/code&gt; not include 15&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;1...15&lt;/code&gt; inlcude 15 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator&quot;&gt;Iterator&lt;/h2&gt;

&lt;p&gt;can apply an expression to each element of an object.
~~~
object.each { |item| # Do something }
~~~&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.times&lt;/code&gt; methods is like a super compact &lt;code&gt;for&lt;/code&gt; loop: it can perform a task on each item in a object a specified number of times.
~~~
10.times { print “Chunky bacon!” }
~~~&lt;/p&gt;

&lt;h2 id=&quot;blockproclambda&quot;&gt;Block,Proc,Lambda&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Block&lt;/code&gt;: A Ruby block is just a bit of code that can be excuted.&lt;/p&gt;

&lt;h3 id=&quot;bolck&quot;&gt;Bolck&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;
my_nums = [1,2,3]
#.collection
my_nums.collection { |num| num ** 2 }
# return [1,4,9]
my_nums.collection! { |num| num ** 2 }
# return [1,4,9] &amp;amp;&amp;amp; my_nums == [1,4,9]


#.each
[1, 2, 3].each do |num|
  puts num
end
# ==&amp;gt; Prints 1, 2, 3 on separate lines
[1, 2, 3].each { |num| puts num }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;yied&quot;&gt;Yied&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def block_test
  puts &quot;We&#39;re in the method!&quot;
  puts &quot;Yielding to the block...&quot;
  yield
  puts &quot;We&#39;re back in the method!&quot;
end

block_test { puts &quot;&amp;gt;&amp;gt;&amp;gt; We&#39;re in the block!&quot; }


def double(n)
    puts &quot;Ori input is #{n}&quot;
    yield(n)
end

double(2) { |n| puts n *2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;proc&quot;&gt;Proc&lt;/h3&gt;
&lt;p&gt;Procs are easy to define! You just call &lt;code&gt;Proc.new&lt;/code&gt; and pass in the block you want to save.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Procs are full-fledged object.&lt;/li&gt;
  &lt;li&gt;This prevents you from haveing to retype the contents of your block every time you need to execute a particular bit of code.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;multiples_of_3 = Proc.new do |n|
  n % 3 == 0
end

(1..100).to_a.select(&amp;amp;multiples_of_3)

multiples_of_3.call
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lambda&quot;&gt;Lambda&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lambda { |param| block }

lambda { puts &quot;Hello!&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lambda-vs-proc&quot;&gt;Lambda VS. Proc&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;A lambda checks the number of arguments passed to it , while a proc does not. This means that a lambda will throw an error if you pass it the worng number of arguments, whereas a proc will ignore unexpected arguments and assign &lt;code&gt;nil&lt;/code&gt; to any that are missing.&lt;/li&gt;
  &lt;li&gt;When a lambda returns , it passes control back to the calling methods; when a proc returns, it does so immediately, without going back to the calling methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;class&quot;&gt;Class&lt;/h1&gt;

&lt;h3 id=&quot;create-a-class&quot;&gt;Create a class&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Message
    @@messages_sent = 0
    def initialize(from, to)
        @from = from
        @to = to
        @@messages_sent += 1
    end
end

my_message = Message.new(&quot;wing.of.war&quot;,&quot;Zhangejue&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if you want to end a Ruby statement without going to a new line, you can just type a semicolon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Monkey
end

to 

class Monkey;end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;set--get&quot;&gt;Set &amp;amp; Get&lt;/h3&gt;

&lt;p&gt;That &lt;code&gt;name=&lt;/code&gt; might look funny, but you’re allowed to put an &lt;code&gt;=&lt;/code&gt; sign in a methods name.
~~~
def name
  @name
end&lt;/p&gt;

&lt;p&gt;def name=(value)
  @name = value
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*equal*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attr_reader :name
attr_writer :job
attr_accessor :job
~~~&lt;/p&gt;

&lt;h2 id=&quot;class-variable&quot;&gt;Class Variable&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;We can create class variable by starting a variable name with two @&lt;/li&gt;
  &lt;li&gt;Only one copy of a class variable shared by all instances of a class.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyClass
	@@class_variable
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;class variable should use a class method to grab it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;inheritance&quot;&gt;Inheritance&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ChildClass &amp;lt; FatherClass
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ChildClass is called: &lt;strong&gt;derived class&lt;/strong&gt; Or &lt;strong&gt;subclasss&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;FatherClass is called: &lt;strong&gt;parent&lt;/strong&gt; or &lt;strong&gt;superclass&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;derived class&lt;/strong&gt; can only have one &lt;strong&gt;superclass&lt;/strong&gt;, not support &lt;strong&gt;multiple inheritance&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class DerivedClass &amp;lt; Base
  def some_method
    super(optional args)
      # Some stuff
    end
  end
end

class Email&amp;lt;Message
    def initialize(from, to)
        super
    end
end

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;publicprivate&quot;&gt;Public&amp;amp;Private&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Note that everything after the &lt;strong&gt;public&lt;/strong&gt; keyword through the &lt;strong&gt;end&lt;/strong&gt; of the class definition will now be public unless we say otherwise.&lt;/li&gt;
  &lt;li&gt;Another way to say this is that the method cannot be called with an explicit receiver.&lt;/li&gt;
  &lt;li&gt;In order to access private information, we have to create public methods that know how to get it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;module&quot;&gt;Module&lt;/h1&gt;

&lt;p&gt;You can think of a &lt;strong&gt;Module&lt;/strong&gt; as a toolbox that contains a set of methods and constants.&lt;/p&gt;

&lt;p&gt;One of the main purposes of modules is to seprate methods and constants into named spaces. That is called &lt;code&gt;namespacing&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It dosent’t make sense to include variables in modules, since variables change.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module MyLibrary
    FAVE_BOOK = &quot;Harry porter&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Math::PI&lt;/code&gt; and &lt;code&gt;Circle::PI&lt;/code&gt;, This is called the &lt;strong&gt;scope resolution operator&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inlcude-a-module&quot;&gt;inlcude a module…&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Angle
  include Math
  attr_accessor :radians
  
  def initialize(radians)
    @radians = radians
  end
  
  def cosine
    cos(@radians)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mixin&quot;&gt;Mixin&lt;/h2&gt;

&lt;p&gt;When a module is used to mix addtional behavior and information into a class, it’s called &lt;strong&gt;mixin&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;include&lt;/code&gt; mixed a module’s methods in at the instance level.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;extend&lt;/code&gt; keyword mixes a module’s methods at the &lt;code&gt;class&lt;/code&gt; level.&lt;/li&gt;
&lt;/ul&gt;

</description>
    </item>
    
    <item>
      <title>ACGArt DownLoader</title>
      <link>place_your_blog_url_here/python/2014/09/13/ACGArt-EN.html</link>
      <pubDate>13 Sep 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/python/2014/09/13/ACGArt-EN</guid>
      <description>&lt;h3 id=&quot;repositoryacgartimagebatchdonehttpsgithubcomwing-of-waracgartimagebatchdone&quot;&gt;&lt;a href=&quot;https://github.com/Wing-Of-War/ACGArtImageBatchDone&quot;&gt;Repository:ACGArtImageBatchDone&lt;/a&gt;&lt;/h3&gt;

&lt;h2 id=&quot;project-origin&quot;&gt;Project Origin&lt;/h2&gt;

&lt;p&gt;Last Year I bought an intersting iOS application named ACG ART&lt;a href=&quot;https://itunes.apple.com/cn/app/acg-art-er-ci-yuan-dong-man/id577006740?mt=8&quot;&gt;APP Store link&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;As you can see, it will provide large number of anime pictures. It’s really briliant.&lt;/p&gt;

&lt;p&gt;But you know mobile phone it’s not a work platform , it is hard to manage and pick the image from the application.(Connection and download are not fast..)
So, I spent two days worktout this little thing to batch download.&lt;/p&gt;

&lt;h2 id=&quot;wow-i-cant-stop-it&quot;&gt;WoW~ I can’t stop it!&lt;/h2&gt;

&lt;h3 id=&quot;downloading&quot;&gt;DownLoading..&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/56becbc4gw1eka8cay4vkj20it0ca436.jpg&quot; alt=&quot;DownLoading..&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pictures&quot;&gt;Pictures&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/56becbc4gw1eka8cable3j20qr0u7q90.jpg&quot; alt=&quot;Pictures&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;please-tell-me&quot;&gt;Please Tell Me&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;If you like it &lt;/li&gt;
  &lt;li&gt;If you have better ideal to impove it &lt;/li&gt;
  &lt;li&gt;If this offend you&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>