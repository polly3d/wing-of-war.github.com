<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 21 Dec 2014 22:03:57 +0800</pubDate>
    <lastBuildDate>Sun, 21 Dec 2014 22:03:57 +0800</lastBuildDate>
    <generator>Jekyll v2.2.0</generator>
    
      <item>
        <title>创建Objective-C数据模型的心得1</title>
        <description>&lt;p&gt;之前自己在公司写iOS应用主要是写的逻辑层与数据层，也算有些心得。所以决定在最近几篇Blog里将一些网上不常见的方法总结一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本期的一个关键方法&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;-(BOOL)isEqual:(id)object;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;basic&quot;&gt;Basic数据模型&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Basic.h&lt;/code&gt;定义了 &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;index: 数据模型在App中的唯一ID  &lt;/li&gt;
  &lt;li&gt;content: 数据模型装载的内容，用于显示  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface Basic : NSObject

@property (assign) NSInteger index;
@property (copy, nonatomic) NSString *content;

- (instancetype)initWithIndex:(NSInteger)index andContent:(NSString *)content;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Basic.m&lt;/code&gt;中实现初始化方法&lt;code&gt;-initWithIndex:andContent;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@implementation Basic
- (instancetype)initWithIndex:(NSInteger)index andContent:(NSString *)content {
  if (self = [super init]) {
    _index = index;
    _content = content;
  }
  return self;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;内存比较&lt;/h3&gt;

&lt;p&gt;常用的逻辑判断中，经常会使用到类似于数据库的&lt;code&gt;插入&lt;/code&gt;、&lt;code&gt;删除&lt;/code&gt;、&lt;code&gt;查找&lt;/code&gt;这几个方法。
这些方法的关键则是对&lt;strong&gt;两个数据模型的比较结果&lt;/strong&gt;，比如NSMutableArray中使用的排序方法
&amp;gt;&lt;code&gt;- (void)sortUsingComparator:(NSComparator)cmptr;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其关键点就是对&lt;code&gt;NSComparator&lt;/code&gt; Block的实现，定义如下：
&amp;gt;&lt;code&gt;typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);&lt;/code&gt;
返回两个对象的&lt;code&gt;关系&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;NSObject中定义的&lt;code&gt;- (BOOL)isEqual:(id)object;&lt;/code&gt;就是对Objective-C中，对象内存地址的判断，如果两个对象所指向的地址相同，则判断为同一对象。在下面的代码中，我先创建了一组Basic对象数据，并且将index=2的对象赋值到了&lt;code&gt;preBasicObj2&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  NSMutableArray *basics = [NSMutableArray array];
  Basic *preBasicObj2 = nil;
  for (NSInteger i = 0 ; i &amp;lt; 5 ; i++) {
    Basic *basic = [[Basic alloc]initWithIndex:i andContent:@&quot;Temp&quot;];
    [basics addObject:basic];
    if (i == 2) {
      preBasicObj2 = basic;
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，再从数组中拿到index=2的对象跟&lt;code&gt;preBasicObj2&lt;/code&gt;进行一系列的比较。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  Basic *arrayObj2 = basics[2];
  BOOL equalResult = [preBasicObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:preBasicObj2];
  NSInteger index = [basics indexOfObject:preBasicObj2];
  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理所当然的从console中输出以下结果：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;equalResult:1&lt;br /&gt;
containResult:1&lt;br /&gt;
index:2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;对象比较1&lt;/h3&gt;

&lt;p&gt;不过在实际开发中，我们拿到的对象可能不只是在内存中操作，仅使用内存比较是不够的。同样一个对象可以由多个地方生成，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户输入&lt;/li&gt;
  &lt;li&gt;网络返回&lt;/li&gt;
  &lt;li&gt;数据库读取&lt;/li&gt;
  &lt;li&gt;Copy方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的测试方法中，我重新创建了index==2的数据对象用于模拟从其它地方读取或者生成的情况。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  Basic *buildObj2 = [[Basic alloc]initWithIndex:2 andContent:@&quot;Temp&quot;];
  BOOL equalResult = [buildObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:buildObj2];
  NSInteger index = [basics indexOfObject:buildObj2];

  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);
        
//Output:
//equalResult:0
//containResult:0
//index:9223372036854775807
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果则如上所示，&lt;strong&gt;不相等&lt;/strong&gt;，&lt;strong&gt;不存在&lt;/strong&gt;，和&lt;strong&gt;找不到&lt;/strong&gt;。所以曾经在相当长的一段时间里，都会使用&lt;code&gt;for循环&lt;/code&gt;来进行判断。后来，我一般会改用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block NS_AVAILABLE(10_6, 4_0);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查找DEMO&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;  __block NSInteger index2 = NSNotFound;
  [basics enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
    Basic *tempObj = (Basic *)obj;
    if (tempObj.index == buildObj2.index) {
      *stop = YES;
      index2 = idx;
    }
  }];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;basic-1&quot;&gt;Basic数据模型“改”&lt;/h2&gt;

&lt;p&gt;直至后来有一次偶然覆写了&lt;code&gt;NSObject&lt;/code&gt;中的&lt;code&gt;-isEqual:&lt;/code&gt;方法。此方法覆写的关键在于你需要知道你的数据模型里，哪一个是可以用于&lt;strong&gt;判断的关键属性&lt;/strong&gt;，类似于数据库中的&lt;code&gt;PRIMARY KEY&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;将下列代码添加于&lt;code&gt;Basic.m&lt;/code&gt;中。&lt;br /&gt;
在&lt;code&gt;-isEqual:&lt;/code&gt;具体实现中，还可以通过&lt;code&gt;==&lt;/code&gt;来判断是否是同一地址和&lt;code&gt;isKindOfClass&lt;/code&gt;判断是否是同一类型的数据模型来增加一些必要的限制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (BOOL)isEqual:(id)object {
  if (self == object) {
    return YES;
  }
  if (![object isKindOfClass:[self class]]) {
    return NO;
  }
  Basic *inputObject = (Basic *)object;
  if (inputObject.index == self.index) {
    return YES;
  }
  return NO;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;对象比较2&lt;/h3&gt;

&lt;p&gt;然后我们重新做一下不同来源的数组对象比较测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-obj&quot;&gt;  Basic *buildObj2 = [[Basic alloc]initWithIndex:2 andContent:@&quot;Temp&quot;];
  BOOL equalResult = [buildObj2 isEqual:arrayObj2];
  BOOL containResult = [basics containsObject:buildObj2];
  NSInteger index = [basics indexOfObject:buildObj2];

  NSLog(@&quot;equalResult:%d \n\
        containResult:%d \n\
        index:%ld &quot;,equalResult, containResult, index);

//Output:
//equalResult:1
//containResult:1
//index:2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;分析数据模型中的关键属性，找到其中的&lt;strong&gt;唯一&lt;/strong&gt;的属性用于实现&lt;code&gt;-isEqual: &lt;/code&gt;的方法。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;-isEqual:&lt;/code&gt;方法的实现可以强化很多&lt;code&gt;集合&lt;/code&gt;类对象中对于&lt;strong&gt;对象存在&lt;/strong&gt;的问题进行强化。&lt;/p&gt;

&lt;p&gt;可以参考自己数据库中的主键，网络服务返回回来的UID等&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Dec 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/12/21/SubClass-Of-%20NSObject.html</link>
        <guid isPermaLink="true">/cn/2014/12/21/SubClass-Of-%20NSObject.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>重置iOS App请求推送授权请求</title>
        <description>&lt;p&gt;在iOS上给自己的App创建推送通并不容易，连测试用户给App进行授权推送通知也是件很麻烦的事情。这将直接关系到用户体验与应用流程的处理。&lt;/p&gt;

&lt;p&gt;之前一直是有在模拟器上测试授权（比如通讯录，月历访问等），通过模拟器的&lt;code&gt;Reset Content and Setting&lt;/code&gt;来重置整个模拟器系统来进行调试。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/e2bf38e87f0c194df27a897c9f945f257bcf83b5/_postsImages/2014/12/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相比其它授权，Push Token是不能只使用模拟器进行测试的，因为iOS的服务器是不会给模拟器下发Push Token的。所以这个流程最好是用真机进行测试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/e2bf38e87f0c194df27a897c9f945f257bcf83b5/_postsImages/2014/12/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但如果使用真机进行反复测试，在之前几乎只有一个办法:  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;通用&lt;/code&gt;-&amp;gt;&lt;code&gt;还原&lt;/code&gt;-&amp;gt;&lt;code&gt;抹掉所有内容和设置&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;清空所有内容不说，整个过程可能还长达数十分钟。&lt;/p&gt;

&lt;p&gt;昨天在和同事感叹这个问题的时候，搜索了一下stackoverflow.com上找到了答案：&lt;/p&gt;

&lt;p&gt;http://stackoverflow.com/questions/2438400/reset-push-notification-settings-for-app&lt;/p&gt;

&lt;p&gt;以及此答案指向的Apple官方解答：&lt;/p&gt;

&lt;p&gt;https://developer.apple.com/library/ios/technotes/tn2010/tn2265.html&lt;/p&gt;

&lt;p&gt;相关文档引用&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;resetting-the-push-notifications-permissions-alert-on-ios&quot;&gt;Resetting the Push Notifications Permissions Alert on iOS&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The first time a push-enabled app registers for push notifications, iOS asks the user if they wish to receive notifications for that app. Once the user has responded to this alert it is not presented again unless the device is restored or the app has been uninstalled for at least a day.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you want to simulate a first-time run of your app, you can leave the app uninstalled for a day. You can achieve the latter without actually waiting a day by following these steps:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Delete your app from the device.&lt;/li&gt;
    &lt;li&gt;Turn the device off completely and turn it back on.&lt;/li&gt;
    &lt;li&gt;Go to Settings &amp;gt; General &amp;gt; Date &amp;amp; Time and set the date ahead a day or more.&lt;/li&gt;
    &lt;li&gt;Turn the device off completely again and turn it back on.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译一下：&lt;/p&gt;

&lt;p&gt;将App从设备上删除&lt;br /&gt;
将设备完全关机再重新启动&lt;br /&gt;
打开 设置-&amp;gt;通用-&amp;gt;日期与时间里 将设备时间拔快一天以上&lt;br /&gt;
将设备再次完全关机再重新启动&lt;/p&gt;

&lt;p&gt;此时再安装你的App可以像纯新的流程一样进行测试所有授权，&lt;/p&gt;

&lt;p&gt;在设置中查看你的App授权选项也是全部重置。&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;

&lt;p&gt;由于之前没有仔细看过相关文档，但可以肯定iOS的授权设置会在设备重新启动时进行更新，而重置的周期需要在一天以上。以后再看到更细的说明再补充。&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Dec 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/12/12/iOS%20Push%20Authoarztion%20Rest-CN.html</link>
        <guid isPermaLink="true">/cn/2014/12/12/iOS%20Push%20Authoarztion%20Rest-CN.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>Golden Path</title>
        <description>&lt;h3 id=&quot;section&quot;&gt;起源&lt;/h3&gt;

&lt;p&gt;上个月的时候，公司要我整理一份iOS的代码规范给大家一起学习和使用。当然自己整理是不太可能的，所以找了一份靠谱的并且自己详细阅读与注释后给大家进行了分享。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;其中有一个章节的内容从分享那一天之后深刻的影响了。此章节很短，所以我直接粘贴在下面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/814f41347a8c6d711b04df58d0a40ae6f7d979ee/_postsImages/2014/12/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Golden Path, 非常好听名字。初次阅读此代码规范的时候我倒也没有太在意，想着只是有个好听的名字就花了三分钟到了下一章节。等到再和公司一有经验的同事一起商量的时候觉得这不仅仅是一个代码规范，更是写出好代码的Golden Key。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简单的理念与规则&lt;/h3&gt;

&lt;p&gt;如果你的代码开始处离你的左侧边框越来越远，整个代码像&lt;code&gt;&amp;gt;&lt;/code&gt;变得越来越深的时候，就会像一个&lt;strong&gt;深坑&lt;/strong&gt;一样散发出坏代码的气味。而好代码的应该是更倾向于&lt;code&gt;]&lt;/code&gt;这种形状的。&lt;/p&gt;

&lt;p&gt;当然，经过一个多月的执行与演化，我个人深化之后总结如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每一个方法内，只处理一件最重要的事情&lt;code&gt;most important thing&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;将与这个&lt;code&gt;most important thing&lt;/code&gt;关系不紧密的部分，提炼成为一个或者多个独立方法进行引用，或者作为执行&lt;code&gt;most important thing&lt;/code&gt;的条件；&lt;/li&gt;
  &lt;li&gt;将执行此方法的判断条件放在前面，排除掉所有不能执行此方法的情况，最后执行&lt;code&gt;something important &lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;多个return的返回是可以接受的。当然，是做为不执行此方法的返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;举一个实例&lt;/h3&gt;

&lt;p&gt;这是逻辑处理层对于UI与数据库建立搜索联系的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)searchContactByEmail:(NSString *email)email withCallback:(void (^)(ContactData *contact))callback{	
	if (emai.length&amp;gt;0 &amp;amp;&amp;amp; [emall rangeOfString:@&quot;@&quot;].length &amp;gt; 0 ) {//1、判断查询的email有效性
		if (self.sharedDB) {//2、判断数据库存在
			ContactData *result =  [self.sharedDB getContactByEmail:email];//3、数据库中查询联系人
			if (callback) {//4、判断回调是否存在
                    callback(result);//5、进行回调
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据之前描述，如此一个简单的方法在&lt;code&gt;callback(result);//5、进行回调 &lt;/code&gt;处已经处于至少5个&lt;code&gt;Tab&lt;/code&gt;的位置，20个&lt;code&gt;Space&lt;/code&gt;的深度，感观上就非常差。逻辑判断也相互嵌套，重点位置不明确。&lt;/p&gt;

&lt;p&gt;详细分析原代码：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;联系人email的有效性判断独立成方法&lt;code&gt;- (BOOL)checkEmailAvailable:(NSString *)email &lt;/code&gt;，这样如果需要改进判断email有效性比如添加正则匹配的时候只用修改此一；&lt;/li&gt;
  &lt;li&gt;判断数据库是否存在应该判断优先级比判断email方法高；&lt;/li&gt;
  &lt;li&gt;在数据库中查询联系人应该是这个方法最重要的一步，应该将其放在此方法靠后的位置；&lt;/li&gt;
  &lt;li&gt;回调方法应该是整个方法运行的前提条件，如果都不需要进行回调返回，那整个方法都不需要运行。&lt;/li&gt;
  &lt;li&gt;回调的位置在最后不变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;经过整理后，代码应该至少是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)searchContactByEmail:(NSString *email)email withCallback:(void (^)(ContactData *contact))callback{
	if (!callback) {
		return;
	}
	if (!self.sharedDB) {
		return;
	}
	if (![self checkEmailAvailable:email]) {
		return;
	}
	ContactData *result = [self.sharedDB getContactByEmail:email];
	callback(result);
}

- (BOOL)checkEmailAvailable:(NSString *)email {
	if (!email.length) {
		return NO;
	}
	if (![email rangeOfString:@&quot;@&quot;].length) {
		return NO;
	}
	return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ios&quot;&gt;再补充一点我个人在iOS开发上的理解：&lt;/h3&gt;

&lt;p&gt;一般的移动客户端上基本上也就是UI调用，逻辑运算，流程控制，网络请求访问等，那么就可以将每一个方法尽可能写得简单，也起到每一个方法注释了一部分的功能 。在引用起来起到方法既是注释的作用。&lt;/p&gt;

&lt;p&gt;我自己之前见过一定要用到if大量嵌套的也就是一些算法，比如快速排序，冒泡排序等，或者是图片渲染，AI计算等有大量不可避免的条件判断。&lt;/p&gt;
</description>
        <pubDate>Fri, 12 Dec 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/12/12/Golden%20Path%20Cn.html</link>
        <guid isPermaLink="true">/cn/2014/12/12/Golden%20Path%20Cn.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>raywenderlich.com Objective-C代码规范中文简易注释</title>
        <description>&lt;h1 id=&quot;the-official-raywenderlichcom-objective-c-style-guide&quot;&gt;The official raywenderlich.com Objective-C style guide.&lt;/h1&gt;

&lt;p&gt;This style guide outlines the coding conventions for raywenderlich.com.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;这份代码规范由&lt;a href=&quot;raywenderlich.com&quot;&gt;raywenderlich.com&lt;/a&gt;编写，原文&lt;a href=&quot;https://github.com/raywenderlich/objective-c-style-guide&quot;&gt;Git&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;中文注释部分由 &lt;a href=&quot;http://wing-of-war.github.io/&quot;&gt;wing.of.war.1980th@gmail&lt;/a&gt; 编写于段落的加重部分;&lt;/li&gt;
  &lt;li&gt;中文主要是对代码规范要点解释，部分为补充说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The reason we made this style guide was so that we could keep the code in our books, tutorials, and starter kits nice and consistent - even though we have many different authors working on the books.&lt;/p&gt;

&lt;p&gt;This style guide is different from other Objective-C style guides you may see, because the focus is centered on readability for print and the web. Many of the decisions were made with an eye toward conserving space for print, easy legibility, and tutorial writing.&lt;/p&gt;

&lt;h2 id=&quot;credits-&quot;&gt;Credits 编写名单&lt;/h2&gt;

&lt;p&gt;The creation of this style guide was a collaborative effort from various raywenderlich.com team members under the direction of Nicholas Waynik.  The team includes: &lt;a href=&quot;https://github.com/moayes&quot;&gt;Soheil Moayedi Azarpour&lt;/a&gt;, &lt;a href=&quot;https://github.com/ricardo-rendoncepeda&quot;&gt;Ricardo Rendon Cepeda&lt;/a&gt;, &lt;a href=&quot;https://github.com/tdahbura&quot;&gt;Tony Dahbura&lt;/a&gt;, &lt;a href=&quot;https://github.com/ColinEberhardt&quot;&gt;Colin Eberhardt&lt;/a&gt;, &lt;a href=&quot;https://github.com/mattjgalloway&quot;&gt;Matt Galloway&lt;/a&gt;, &lt;a href=&quot;https://github.com/gregheo&quot;&gt;Greg Heo&lt;/a&gt;, &lt;a href=&quot;https://github.com/hollance&quot;&gt;Matthijs Hollemans&lt;/a&gt;, &lt;a href=&quot;https://github.com/elephantronic&quot;&gt;Christopher LaPollo&lt;/a&gt;, &lt;a href=&quot;https://github.com/casademora&quot;&gt;Saul Mora&lt;/a&gt;, &lt;a href=&quot;https://github.com/macandyp&quot;&gt;Andy Pereira&lt;/a&gt;, &lt;a href=&quot;https://github.com/micpringle&quot;&gt;Mic Pringle&lt;/a&gt;, &lt;a href=&quot;https://github.com/pietrorea&quot;&gt;Pietro Rea&lt;/a&gt;, &lt;a href=&quot;https://github.com/funkyboy&quot;&gt;Cesare Rocchi&lt;/a&gt;, &lt;a href=&quot;https://github.com/icanzilb&quot;&gt;Marin Todorov&lt;/a&gt;, &lt;a href=&quot;https://github.com/ndubbs&quot;&gt;Nicholas Waynik&lt;/a&gt;, and &lt;a href=&quot;https://github.com/raywenderlich&quot;&gt;Ray Wenderlich&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We would like to thank the creators of the &lt;a href=&quot;https://github.com/NYTimes/objective-c-style-guide&quot;&gt;New York Times&lt;/a&gt; and &lt;a href=&quot;https://github.com/RobotsAndPencils/objective-c-style-guide&quot;&gt;Robots &amp;amp; Pencils’&lt;/a&gt; Objective-C Style Guides.  These two style guides provided a solid starting point for this guide to be created and based upon.&lt;/p&gt;

&lt;h2 id=&quot;background-&quot;&gt;Background 参考&lt;/h2&gt;

&lt;p&gt;Here are some of the documents from Apple that informed the style guide. If something isn’t mentioned here, it’s probably covered in great detail in one of these:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html&quot;&gt;The Objective-C Programming Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html&quot;&gt;Cocoa Fundamentals Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html&quot;&gt;Coding Guidelines for Cocoa&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html&quot;&gt;iOS App Programming Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;table-of-contents&quot;&gt;Table of Contents&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#language&quot;&gt;Language&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#code-organization&quot;&gt;Code Organization&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#spacing&quot;&gt;Spacing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#comments&quot;&gt;Comments&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#naming&quot;&gt;Naming&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#underscores&quot;&gt;Underscores&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#methods&quot;&gt;Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#variables&quot;&gt;Variables&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#property-attributes&quot;&gt;Property Attributes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#dot-notation-syntax&quot;&gt;Dot-Notation Syntax&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#literals&quot;&gt;Literals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#constants&quot;&gt;Constants&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#enumerated-types&quot;&gt;Enumerated Types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#case-statements&quot;&gt;Case Statements&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#private-properties&quot;&gt;Private Properties&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#booleans&quot;&gt;Booleans&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conditionals&quot;&gt;Conditionals&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ternary-operator&quot;&gt;Ternary Operator&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#init-methods&quot;&gt;Init Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#cgrect-functions&quot;&gt;CGRect Functions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#golden-path&quot;&gt;Golden Path&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#error-handling&quot;&gt;Error handling&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#singletons&quot;&gt;Singletons&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#line-breaks&quot;&gt;Line Breaks&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#smiley-face&quot;&gt;Smiley Face&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#xcode-project&quot;&gt;Xcode Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;language&quot;&gt;Language&lt;/h2&gt;

&lt;p&gt;US English should be used.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用美式英语和单词拼写，见过用法语和日语拼音的变量，识别困难。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIColor *myColor = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIColor *myColour = [UIColor whiteColor];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;code-organization-&quot;&gt;Code Organization 代码组织&lt;/h2&gt;

&lt;p&gt;Use &lt;code&gt;#pragma mark -&lt;/code&gt; to categorize methods in functional groupings and protocol/delegate implementations following this general structure.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 &lt;code&gt;#pragma mark -&lt;/code&gt; 把相同功能的代码放入同一代码区中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;保持&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;文件内的代码分块一致与顺序一致。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;#pragma mark - Lifecycle

- (instancetype)init {...}

- (void)dealloc {...}

- (void)viewDidLoad {...}

- (void)viewWillAppear:(BOOL)animated {...}

- (void)didReceiveMemoryWarning {...}

#pragma mark - Custom Accessors

- (void)setCustomProperty:(id)value {...}

- (id)customProperty {...}

#pragma mark - IBActions

- (IBAction)submitData:(id)sender {...}

#pragma mark - Public

- (void)publicMethod {...}

#pragma mark - Private

- (void)privateMethod {...}

#pragma mark - Protocol conformance
#pragma mark - UITextFieldDelegate
#pragma mark - UITableViewDataSource
#pragma mark - UITableViewDelegate

#pragma mark - NSCopying

- (id)copyWithZone:(NSZone *)zone {...}

#pragma mark - NSObject

- (NSString *)description {...}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;额外：如果有次级分组，使用 &lt;code&gt;#pragma mark &lt;/code&gt;划分子代码区。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;
#pragma mark - Main Func

- (void)sync;

#pragma mark Add

- (void)add:(id)obj;
- (void)adds:(NSArray *)objs;

#pragma mark Update

- (void)update:(id)obj;
- (void)update:(NSArray *)objs;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;spacing&quot;&gt;Spacing空格&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Indent using 2 spaces (this conserves space in print and makes line wrapping less likely). Never indent with tabs. Be sure to set this preference in Xcode.
    &lt;ul&gt;
      &lt;li&gt;XCODE默认换行是4个空格，推 荐使用2个空格，让代码看起来更紧凑，&lt;/li&gt;
      &lt;li&gt;设置方法:&lt;code&gt;xcode&lt;/code&gt;-&amp;gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;Text Editing&lt;/code&gt;-&amp;gt;&lt;code&gt;Indentation&lt;/code&gt;-&amp;gt;&lt;code&gt;Indent width&lt;/code&gt;。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Method braces and other braces (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; etc.) always open on the same line as the statement but close on a new line.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;* 方法体`{}`的开始`{`与方法和`if`/`else`/`switch`/`while`控制流方法处于同一行，`}`则需要另起一行。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (user.isHappy) {
  //Do something
} else {
  //Do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (user.isHappy)
{
    //Do something
}
else {
    //Do something else
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;There should be exactly one blank line between methods to aid in visual clarity and organization. Whitespace within methods should separate functionality, but often there should probably be new methods.
    &lt;ul&gt;
      &lt;li&gt;方法之间应该保持一个空行，有助于保持清晰的结构。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Prefer using auto-synthesis. But if necessary, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic&lt;/code&gt; should each be declared on new lines in the implementation.
    &lt;ul&gt;
      &lt;li&gt;推荐使用&lt;code&gt;auto-property-synthesis&lt;/code&gt;自动生成属性的Set,Get方法；&lt;/li&gt;
      &lt;li&gt;如果需要，每一个&lt;code&gt;@synthesize&lt;/code&gt; 和 &lt;code&gt;@dynamic&lt;/code&gt;都应该独占一行。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Colon-aligning method invocation should often be avoided.  There are cases where a method signature may have &amp;gt;= 3 colons and colon-aligning makes the code more readable. Please do &lt;strong&gt;NOT&lt;/strong&gt; however colon align methods containing blocks because Xcode’s indenting makes it illegible.
    &lt;ul&gt;
      &lt;li&gt;多个回调模块，使用&lt;code&gt;{}&lt;/code&gt;括号的对齐比使用 方法名中的&lt;code&gt;:&lt;/code&gt;对齐要便于阅读。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;// blocks are easily readable
[UIView animateWithDuration:1.0 animations:^{
  // something
} completion:^(BOOL finished) {
  // something
}];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;// colon-aligning makes the block indentation hard to read
// 冒号对齐让block模块缩进难以阅读

[UIView animateWithDuration:1.0
                 animations:^{
                     // something
                 }
                 completion:^(BOOL finished) {
                     // something
                 }];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;comments&quot;&gt;Comments&lt;/h2&gt;

&lt;p&gt;When they are needed, comments should be used to explain &lt;strong&gt;why&lt;/strong&gt; a particular piece of code does something. Any comments that are used must be kept up-to-date or deleted.&lt;/p&gt;

&lt;p&gt;Block comments should generally be avoided, as code should be as self-documenting as possible, with only the need for intermittent, few-line explanations. &lt;em&gt;Exception: This does not apply to those comments used to generate documentation.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注释及时更新，或者直接删除；&lt;/li&gt;
  &lt;li&gt;只有在复杂的地方才需要；&lt;/li&gt;
  &lt;li&gt;代码如注释。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;naming-&quot;&gt;Naming 命名&lt;/h2&gt;

&lt;p&gt;Apple naming conventions should be adhered to wherever possible, especially those related to &lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html&quot;&gt;memory management rules&lt;/a&gt; (&lt;a href=&quot;http://stackoverflow.com/a/2865194/340508&quot;&gt;NARC&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Long, descriptive method and variable names are good.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;鼓励使用完整，并且有描述性的变量名和方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIButton *settingsButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;UIButton *setBut;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A three letter prefix should always be used for class names and constants, however may be omitted for Core Data entity names. For any official raywenderlich.com books, starter kits, or tutorials, the prefix ‘RWT’ should be used.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三个首字母的缩写仅用于类名和常量之中。（并且大写）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Constants should be camel-case with all words capitalized and prefixed by the related class name for clarity.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;驼峰命名。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSTimeInterval const fadetime = 1.7;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Properties should be camel-case with the leading word being lowercase. Use auto-synthesis for properties rather than manual @synthesize statements unless you have good reason.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果充分的理由，使用自动变量赋值方法，而不是自己实现&lt;code&gt;@synthesize&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (strong, nonatomic) NSString *descriptiveVariableName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;id varnm;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;underscores&quot;&gt;Underscores&lt;/h3&gt;

&lt;p&gt;When using properties, instance variables should always be accessed and mutated using &lt;code&gt;self.&lt;/code&gt;. This means that all properties will be visually distinct, as they will all be prefaced with &lt;code&gt;self.&lt;/code&gt;. &lt;/p&gt;

&lt;p&gt;An exception to this: inside initializers, the backing instance variable (i.e. _variableName) should be used directly to avoid any potential side effects of the getters/setters.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了init初始化方法中使用&lt;code&gt;_variableName&lt;/code&gt;来获取或者设置值之外，都应该使用&lt;code&gt;self.&lt;/code&gt;来获取变量，实例中的值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Local variables should not contain underscores.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本地变量不应该包含下划线。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;methods&quot;&gt;Methods&lt;/h2&gt;

&lt;p&gt;In method signatures, there should be a space after the method type (-/+ symbol). &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法名和方法类型&lt;code&gt;（-/+）&lt;/code&gt;之间有一个空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There should be a space between the method segments (matching Apple’s style). &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法片段间有空格。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Always include a keyword and be descriptive with the word before the argument which describes the argument.&lt;/p&gt;

&lt;p&gt;The usage of the word “and” is reserved.  It should not be used for multiple parameters as illustrated in the &lt;code&gt;initWithWidth:height:&lt;/code&gt; example below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多个参数名前的方法要有描述性的关键字,并且不要包含&lt;strong&gt;and&lt;/strong&gt;字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)setExampleText:(NSString *)text image:(UIImage *)image;
- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;-(void)setT:(NSString *)text i:(UIImage *)image;
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
- (instancetype)initWith:(int)width and:(int)height;  // Never do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Particular：参数名在方法的最后&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (id)viewWithTag:(NSInteger)tag;
//Not Preferred
- (id)taggedView:(NSInteger)tag;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;variables&quot;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Variables should be named as descriptively as possible. Single letter variable names should be avoided except in &lt;code&gt;for()&lt;/code&gt; loops.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除了在流控制方法中的临时变量，变量名应该是有一定描述性的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Asterisks indicating pointers belong with the variable, e.g., &lt;code&gt;NSString *text&lt;/code&gt; not &lt;code&gt;NSString* text&lt;/code&gt; or &lt;code&gt;NSString * text&lt;/code&gt;, except in the case of constants.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;*&lt;/code&gt;与变量名紧靠在一起。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;#private-properties&quot;&gt;Private properties&lt;/a&gt; should be used in place of instance variables whenever possible. Although using instance variables is a valid way of doing things, by agreeing to prefer properties our code will be more consistent. &lt;/p&gt;

&lt;p&gt;Direct access to instance variables that ‘back’ properties should be avoided except in initializer methods (&lt;code&gt;init&lt;/code&gt;, &lt;code&gt;initWithCoder:&lt;/code&gt;, etc…), &lt;code&gt;dealloc&lt;/code&gt; methods and within custom setters and getters. For more information on using Accessor Methods in Initializer Methods and dealloc, see &lt;a href=&quot;https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;除&lt;code&gt;init&lt;/code&gt;,&lt;code&gt;dealloc&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;,&lt;code&gt;get&lt;/code&gt;等此类方法，应该尽量使用&lt;code&gt;setters&lt;/code&gt;和&lt;code&gt;getters&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTTutorial : NSObject

@property (strong, nonatomic) NSString *tutorialName;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTTutorial : NSObject {
  NSString *tutorialName;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;property-attributes&quot;&gt;Property Attributes&lt;/h2&gt;

&lt;p&gt;Property attributes should be explicitly listed, and will help new programmers when reading the code.  The order of properties should be storage then atomicity, which is consistent with automatically generated code when connecting UI elements from Interface Builder.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;变量申明时，原子属性在存储之后。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (weak, nonatomic) IBOutlet UIView *containerView;
@property (strong, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Properties with mutable counterparts (e.g. NSString) should prefer &lt;code&gt;copy&lt;/code&gt; instead of &lt;code&gt;strong&lt;/code&gt;. 
Why? Even if you declared a property as &lt;code&gt;NSString&lt;/code&gt; somebody might pass in an instance of an &lt;code&gt;NSMutableString&lt;/code&gt; and then change it without you noticing that.  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;经常变更的变量更倾向于使用&lt;code&gt;copy&lt;/code&gt;，而不是&lt;code&gt;strong&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (copy, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (strong, nonatomic) NSString *tutorialName;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;以下引用&lt;a href=&quot;http://blog.csdn.net/itianyi/article/details/9018567&quot;&gt;NSString什么时候用copy，什么时候用strong&lt;/a&gt;对此例进行说明。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (retain,nonatomic) NSString *rStr;
@property (copy, nonatomic)   NSString *cStr;

- (void)test:
{
    NSMutableString *mStr = [NSMutableStringstringWithFormat:@&quot;abc&quot;];
    self.rStr   = mStr;
    self.cStr     = mStr;
    NSLog(@&quot;mStr:%p,%p&quot;,  mStr,&amp;amp;mStr);
    NSLog(@&quot;retainStr:%p,%p&quot;, _rStr, &amp;amp;_rStr);
    NSLog(@&quot;copyStr:%p,%p&quot;,   _cStr, &amp;amp;_cStr);
｝

/*
假如，mStr对象的地址为0x11，也就是0x11是@“abc”的首地址，mStr变量自身在内存中的地址为0x123；
当把mStr赋值给retain的rStr时，rStr对象的地址为0x11，rStr变量自身在内存中的地址为0x124；rStr与mStr指向同样的地址，他们指向的是同一个对象@“abc”，这个对象的地址为0x11，所以他们的值是一样的。
当把mStr赋值给copy的cStr时，cStr对象的地址为0x22，cStr变量自身在内存中的地址0x125；cStr与mStr指向的地址是不一样的，他们指向的是不同的对象，所以copy是深复制，一个新的对象，这个对象的地址为0x22，值为@“abc”。

如果现在改变mStr的值：
    [mStr appendString:@&quot;de&quot;];
    NSLog(@&quot;retainStr:%@&quot;,  _rStr);
    NSLog(@&quot;copyStr:%@&quot;,    _cStr);

结果，
使用retain的字串rStr的值：@&quot;abcde&quot;,
而使用copy的字串cStr的值:@&quot;abc&quot;,
所以，如果一般情况下，我们都不希望字串的值跟着mStr变化，所以我们一般用copy来设置string的属性。
如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。
注意：上面的情况是针对于当把NSMutableString赋值给NSString的时候，才会有不同，如果是赋值是NSString对象，那么使用copy还是strong，结果都是一样的，因为NSString对象根本就不能改变自身的值，他是不可变的。

把一个对象赋值给一个属性变量，当这个对象变化了，如果希望属性变量变化就使用strong属性，如果希望属性变量不跟着变化，就是用copy属性。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dot-notation-syntax--&quot;&gt;Dot-Notation Syntax 点表达式 句法&lt;/h2&gt;

&lt;p&gt;Dot syntax is purely a convenient wrapper around accessor method calls. When you use dot syntax, the property is still accessed or changed using getter and setter methods.  Read more &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dot-notation should &lt;strong&gt;always&lt;/strong&gt; be used for accessing and mutating properties, as it makes code more concise. Bracket notation is preferred in all other instances.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;点表达式应该是用于获取或者改变属性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其它实例方法，都推荐使用&lt;code&gt;[]&lt;/code&gt;&lt;strong&gt;括号记法&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger arrayCount = [self.array count];
view.backgroundColor = [UIColor orangeColor];
[UIApplication sharedApplication].delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger arrayCount = self.array.count;
[view setBackgroundColor:[UIColor orangeColor]];
UIApplication.sharedApplication.delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;literals-&quot;&gt;Literals 字面量&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Literals翻译成字面量或者字面值，就是直接被写到源代码中的值&lt;a href=&quot;http://my.oschina.net/iamzkt/blog/127718&quot;&gt;Objective-C 之 Literals（字面量）&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它的语法很简单，上面的代码就是通过在C字符串的前面加上@符号创建了一个NSString对象greeting，整段代码看起来简洁易懂，如果没有直接量语法，那么创建这个greeting可能就要使用下面的方法了：
~~~objc
NSString *greeting = [NSString stringWithUTF8String:”Hello World”];
~~~&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;NSString&lt;/code&gt;, &lt;code&gt;NSDictionary&lt;/code&gt;, &lt;code&gt;NSArray&lt;/code&gt;, and &lt;code&gt;NSNumber&lt;/code&gt; literals should be used whenever creating immutable instances of those objects. Pay special care that &lt;code&gt;nil&lt;/code&gt; values can not be passed into &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;NSDictionary&lt;/code&gt; literals, as this will cause a crash.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];
NSDictionary *productManagers = @{@&quot;iPhone&quot;: @&quot;Kate&quot;, @&quot;iPad&quot;: @&quot;Kamal&quot;, @&quot;Mobile Web&quot;: @&quot;Bill&quot;};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingStreetNumber = @10018;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSArray *names = [NSArray arrayWithObjects:@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;, nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @&quot;Kate&quot;, @&quot;iPhone&quot;, @&quot;Kamal&quot;, @&quot;iPad&quot;, @&quot;Bill&quot;, @&quot;Mobile Web&quot;, nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;constants-&quot;&gt;Constants 常量&lt;/h2&gt;

&lt;p&gt;Constants are preferred over in-line string literals or numbers, as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace. Constants should be declared as &lt;code&gt;static&lt;/code&gt; constants and not &lt;code&gt;#define&lt;/code&gt;s unless explicitly being used as a macro.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量使用&lt;code&gt;static&lt;/code&gt;与&lt;code&gt;const&lt;/code&gt;创建，&lt;code&gt;#define&lt;/code&gt;可以用于定义便利方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;static NSString * const RWTAboutViewControllerCompanyName = @&quot;RayWenderlich.com&quot;;

static CGFloat const RWTImageThumbnailHeight = 50.0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;#define CompanyName @&quot;RayWenderlich.com&quot;

#define thumbnailHeight 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;enumerated-types&quot;&gt;Enumerated Types&lt;/h2&gt;

&lt;p&gt;When using &lt;code&gt;enum&lt;/code&gt;s, it is recommended to use the new fixed underlying type specification because it has stronger type checking and code completion. The SDK now includes a macro to facilitate and encourage use of fixed underlying types: &lt;code&gt;NS_ENUM()&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;推荐使用代码提示中宏定义的&lt;code&gt;NS_ENUM()&lt;/code&gt;枚举模块来创建，它可以提供更严谨的类型检测和代码补完功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;For Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) {
  RWTLeftMenuTopItemMain,
  RWTLeftMenuTopItemShows,
  RWTLeftMenuTopItemSchedule
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also make explicit value assignments (showing older k-style constant definition):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;typedef NS_ENUM(NSInteger, RWTGlobalConstants) {
  RWTPinSizeMin = 1,
  RWTPinSizeMax = 5,
  RWTPinCountMin = 100,
  RWTPinCountMax = 500,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Older k-style constant definitions should be &lt;strong&gt;avoided&lt;/strong&gt; unless writing CoreFoundation C code (unlikely).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;传统的枚举则让代码看起来更像C。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;enum GlobalConstants {
  kMaxPinSize = 5,
  kMaxPinCount = 500,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;case-statements-&quot;&gt;Case Statements 分支&lt;/h2&gt;

&lt;p&gt;Braces are not required for case statements, unless enforced by the complier.&lt;br /&gt;
When a case contains more than one line, braces should be added.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每一个&lt;code&gt;case&lt;/code&gt;分支下的执行语句，如果只有一行，不加&lt;code&gt;{}&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;如果&lt;code&gt;case&lt;/code&gt;分支下的执行语句有多行，则使用&lt;code&gt;{}&lt;/code&gt;划定范围。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;switch (condition) {
  case 1:
    // ...
    break;
  case 2: {
    // ...
    // Multi-line example using braces
    break;
  }
  case 3:
    // ...
    break;
  default: 
    // ...
    break;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are times when the same code can be used for multiple cases, and a fall-through should be used.  A fall-through is the removal of the ‘break’ statement for a case thus allowing the flow of execution to pass to the next case value.  A fall-through should be commented for coding clarity.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;相同&lt;code&gt;case&lt;/code&gt;分支的条件使用&lt;code&gt;条件继承 fall-through&lt;/code&gt;，在上层&lt;code&gt;case&lt;/code&gt;中不使用&lt;code&gt;break&lt;/code&gt;跳出，直接继承下层&lt;code&gt;case&lt;/code&gt;的执行语句。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;switch (condition) {
  case 1:
    // ** fall-through! **
  case 2:
    // code executed for values 1 and 2
    break;
  default: 
    // ...
    break;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using an enumerated type for a switch, ‘default’ is not needed.   For example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;default&lt;/code&gt;条件非必需&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;

switch (menuType) {
  case RWTLeftMenuTopItemMain:
    // ...
    break;
  case RWTLeftMenuTopItemShows:
    // ...
    break;
  case RWTLeftMenuTopItemSchedule:
    // ...
    break;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;private-properties&quot;&gt;Private Properties&lt;/h2&gt;

&lt;p&gt;Private properties should be declared in class extensions (anonymous categories) in the implementation file of a class. Named categories (such as &lt;code&gt;RWTPrivate&lt;/code&gt; or &lt;code&gt;private&lt;/code&gt;) should never be used unless extending another class.   The Anonymous category can be shared/exposed for testing using the &lt;headerfile&gt;+Private.h file naming convention.&lt;/headerfile&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;私有变更应该在类的私有类别中，不需要加&lt;code&gt;private&lt;/code&gt;等词语来进行修饰。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;私有类别可以在命名为&lt;code&gt;&amp;lt;headerfile&amp;gt;+Private.h&lt;/code&gt;的文件里提供&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;For Example:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface RWTDetailViewController ()

@property (strong, nonatomic) GADBannerView *googleAdView;
@property (strong, nonatomic) ADBannerView *iAdView;
@property (strong, nonatomic) UIWebView *adXWebView;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;booleans&quot;&gt;Booleans&lt;/h2&gt;

&lt;p&gt;Objective-C uses &lt;code&gt;YES&lt;/code&gt; and &lt;code&gt;NO&lt;/code&gt;.  Therefore &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; should only be used for CoreFoundation, C or C++ code.  Since &lt;code&gt;nil&lt;/code&gt; resolves to &lt;code&gt;NO&lt;/code&gt; it is unnecessary to compare it in conditions. &lt;/p&gt;

&lt;p&gt;Never compare something directly to &lt;code&gt;YES&lt;/code&gt;, because &lt;code&gt;YES&lt;/code&gt; is defined to 1 and a &lt;code&gt;BOOL&lt;/code&gt; can be up to 8 bits.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不要把对象直接和&lt;code&gt;YES&lt;/code&gt;进行比较，&lt;/li&gt;
  &lt;li&gt;可以覆写类继承自&lt;code&gt;NSOjbect&lt;/code&gt;下的&lt;code&gt;-(BOOL)isEqual:(id)obj;&lt;/code&gt;方法来类的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This allows for more consistency across files and greater visual clarity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (someObject) {}
if (![anotherObject boolValue]) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (someObject == nil) {}
if ([anotherObject boolValue] == NO) {}
if (isAwesome == YES) {} // Never do this.
if (isAwesome == true) {} // Never do this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the name of a &lt;code&gt;BOOL&lt;/code&gt; property is expressed as an adjective, the property can omit the “is” prefix but specifies the conventional name for the get accessor, for example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果&lt;code&gt;BOOL&lt;/code&gt;变量是形容词，不需要&lt;strong&gt;is&lt;/strong&gt;来进行修饰。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@property (assign, getter=isEditable) BOOL editable;
//**Not Preferred:**
//@property (assign, getter=isEditable) BOOL isEditable;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Text and example taken from the &lt;a href=&quot;https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE&quot;&gt;Cocoa Naming Guidelines&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conditionals&quot;&gt;Conditionals&lt;/h2&gt;

&lt;p&gt;Conditional bodies should always use braces even when a conditional body could be written without braces (e.g., it is one line only) to prevent errors. These errors include adding a second line and expecting it to be part of the if-statement. Another, &lt;a href=&quot;http://programmers.stackexchange.com/a/16530&quot;&gt;even more dangerous defect&lt;/a&gt; may happen where the line “inside” the if-statement is commented out, and the next line unwittingly becomes part of the if-statement. In addition, this style is more consistent with all other conditionals, and therefore more easily scannable.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一定使用&lt;code&gt;{}&lt;/code&gt;来划定判断后的执行语句；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;即使执行语非常简单，也不能与条件判断在一行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error) {
  return success;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error)
  return success;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;if (!error) return success;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ternary-operator-&quot;&gt;Ternary Operator 三元运算符&lt;/h3&gt;

&lt;p&gt;The Ternary operator, &lt;code&gt;?:&lt;/code&gt; , should only be used when it increases clarity or code neatness. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;只有在确定能够促进代码整洁与清晰的前提下才使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A single condition is usually all that should be evaluated. Evaluating multiple conditions is usually more understandable as an &lt;code&gt;if&lt;/code&gt; statement, or refactored into instance variables. &lt;/p&gt;

&lt;p&gt;In general, the best use of the ternary operator is during assignment of a variable and deciding which value to use.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;三元运算符最好在赋值需要判断时使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Non-boolean variables should be compared against something, and parentheses are added for improved readability.  If the variable being compared is a boolean type, then no parentheses are needed.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非BOOL类型变量必须要与其类型变量做出判断后才能使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSInteger value = 5;
result = (value != 0) ? x : y;

BOOL isHorizontal = YES;
result = isHorizontal ? x : y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;result = a &amp;gt; b ? x = c &amp;gt; d ? c : d : y;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;init-methods&quot;&gt;Init Methods&lt;/h2&gt;

&lt;p&gt;Init methods should follow the convention provided by Apple’s generated code template.  A return type of ‘instancetype’ should also be used instead of ‘id’.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;init&lt;/code&gt;方法中返回值使用&lt;code&gt;instancetype&lt;/code&gt;取代&lt;code&gt;id&lt;/code&gt;作为返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (instancetype)init {
  self = [super init];
  if (self) {
    // ...
  }
  return self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See &lt;a href=&quot;#class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/a&gt; for link to article on instancetype.&lt;/p&gt;

&lt;h2 id=&quot;class-constructor-methods&quot;&gt;Class Constructor Methods&lt;/h2&gt;

&lt;p&gt;Where class constructor methods are used, these should always return type of ‘instancetype’ and never ‘id’. This ensures the compiler correctly infers the result type. &lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;@interface Airplane
+ (instancetype)airplaneWithType:(RWTAirplaneType)type;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on instancetype can be found on &lt;a href=&quot;http://nshipster.com/instancetype/&quot;&gt;NSHipster.com&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;以下摘取自&lt;a href=&quot;http://blog.csdn.net/wzzvictory/article/details/16994913&quot;&gt;Objective-C中的instancetype和id关键字&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;三、instancetype作用
1、作用
如果一个不是关联返回类型的方法，如下：

@interface NSArray  
+ (id)constructAnArray;  
@end  
当我们使用如下方式初始化NSArray时：


[NSArray constructAnArray];  
根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id。
但是如果使用instancetype作为返回类型，如下：


@interface NSArray  
+ (instancetype)constructAnArray;  
@end  
当使用相同方式初始化NSArray时：

[NSArray constructAnArray];  
得到的返回类型和方法所在类的类型相同，是NSArray*!
总结一下，instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！

2、好处
能够确定对象的类型，能够帮助编译器更好的为我们定位代码书写问题，比如：

[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; //  &quot;No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`&quot;  
  
[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error)  
上例中第一行代码，由于[[NSArray alloc]init]的结果是NSArray*，这样编译器就能够根据返回的数据类型检测出NSArray是否实现mediaPlaybackAllowsAirPlay方法。有利于开发者在编译阶段发现错误。
第二行代码，由于array不属于关联返回类型方法，[NSArray array]返回的是id类型，编译器不知道id类型的对象是否实现了mediaPlaybackAllowsAirPlay方法，也就不能够替开发者及时发现错误。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;cgrect-functions&quot;&gt;CGRect Functions&lt;/h2&gt;

&lt;p&gt;When accessing the &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, or &lt;code&gt;height&lt;/code&gt; of a &lt;code&gt;CGRect&lt;/code&gt;, always use the &lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html&quot;&gt;&lt;code&gt;CGGeometry&lt;/code&gt; functions&lt;/a&gt; instead of direct struct member access. From Apple’s &lt;code&gt;CGGeometry&lt;/code&gt; reference:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;CGGeometry&lt;/code&gt;方法来获取&lt;code&gt;CGRect&lt;/code&gt;结构下的长宽位置值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;CGRect frame = self.view.frame;

CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);
CGRect frame = CGRectMake(0.0, 0.0, width, height);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;CGRect frame = self.view.frame;

CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
CGRect frame = (CGRect){ .origin = CGPointZero, .size = frame.size };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;golden-path&quot;&gt;Golden Path&lt;/h2&gt;

&lt;p&gt;When coding with conditionals, the left hand margin of the code should be the “golden” or “happy” path.  That is, don’t nest &lt;code&gt;if&lt;/code&gt; statements.  Multiple return statements are OK.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;条件判断的左侧空间被称为&lt;strong&gt;黄金路径&lt;/strong&gt;或者&lt;strong&gt;幸福路径&lt;/strong&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减少&lt;code&gt;if&lt;/code&gt;的条件的嵌套，扁平化多个返回条件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数的多个返回条件是可以接受的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)someMethod {
  if (![someOther boolValue]) {
	return;
  }

  //Do something important
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;- (void)someMethod {
  if ([someOther boolValue]) {
    //Do something important
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Demo:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;    if (text.length &amp;gt; 0) {
        WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
        if (contact) {
            [_sentTo addObject:contact];
            [self setSearchTableShow:NO];
            tokenField.inputText = @&quot;&quot;;
            [tokenField reloadData];
       }
    } else {
        [_subjectTokenField becomeFirstResponder];
    }

//Rebuild:

    if (text.length &amp;lt;= 0) {
        [_subjectTokenField becomeFirstResponder];
        return;
    }
    WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
    if (!contact) {
        return;
    }
    [_sentTo addObject:contact];
    [self setSearchTableShow:NO];
    tokenField.inputText = @&quot;&quot;;
    [tokenField reloadData];

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;error-handling&quot;&gt;Error handling&lt;/h2&gt;

&lt;p&gt;When methods return an error parameter by reference, switch on the returned value, not the error variable.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;条件判断错误时，应该是错误变量本身。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSError *error;
if (![self trySomethingWithError:&amp;amp;error]) {
  // Handle Error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;NSError *error;
[self trySomethingWithError:&amp;amp;error];
if (error) {
  // Handle Error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some of Apple’s APIs write garbage values to the error parameter (if non-NULL) in successful cases, so switching on the error can cause false negatives (and subsequently crash).&lt;/p&gt;

&lt;h2 id=&quot;singletons&quot;&gt;Singletons&lt;/h2&gt;

&lt;p&gt;Singleton objects should use a thread-safe pattern for creating their shared instance.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单例必须线程安全。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;+ (instancetype)sharedInstance {
  static id sharedInstance = nil;

  static dispatch_once_t onceToken;
  dispatch_once(&amp;amp;onceToken, ^{
    sharedInstance = [[self alloc] init];
  });

  return sharedInstance;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will prevent &lt;a href=&quot;http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html&quot;&gt;possible and sometimes prolific crashes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;line-breaks&quot;&gt;Line Breaks&lt;/h2&gt;

&lt;p&gt;Line breaks are an important topic since this style guide is focused for print and online readability.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A long line of code like this should be carried on to the second line adhering to this style guide’s Spacing section (two spaces).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为代码太长需要换行时，与首行有两个空格间隔；&lt;/li&gt;
  &lt;li&gt;设置方法：&lt;code&gt;xcode&lt;/code&gt;-&amp;gt;&lt;code&gt;preferences&lt;/code&gt;-&amp;gt;&lt;code&gt;Text Editing&lt;/code&gt;-&amp;gt;&lt;code&gt;Indentation&lt;/code&gt;-&amp;gt;&lt;code&gt;Line Wrapping&lt;/code&gt; 手动设置为&lt;code&gt;2&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;self.productsRequest = [[SKProductsRequest alloc] 
  initWithProductIdentifiers:productIdentifiers];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;smiley-face&quot;&gt;Smiley Face&lt;/h2&gt;

&lt;p&gt;Smiley faces are a very prominent style feature of the raywenderlich.com site!  It is very important to have the correct smile signifying the immense amount of happiness and excitement for the coding topic.  The end square bracket is used because it represents the largest smile able to be captured using ascii art.  A half-hearted smile is represented if an end parenthesis is used, and thus not preferred.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code&gt;]&lt;/code&gt;看起来比&lt;code&gt;)&lt;/code&gt;笑得更开心&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;:]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Not Preferred:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objc&quot;&gt;:)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;xcode-project&quot;&gt;Xcode project&lt;/h2&gt;

&lt;p&gt;The physical files should be kept in sync with the Xcode project files in order to avoid file sprawl. Any Xcode groups created should be reflected by folders in the filesystem. Code should be grouped not only by type, but also by feature for greater clarity.&lt;/p&gt;

&lt;p&gt;When possible, always turn on “Treat Warnings as Errors” in the target’s Build Settings and enable as many &lt;a href=&quot;http://boredzo.org/blog/archives/2009-11-07/warnings&quot;&gt;additional warnings&lt;/a&gt; as possible. If you need to ignore a specific warning, use &lt;a href=&quot;http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas&quot;&gt;Clang’s pragma feature&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;other-objective-c-style-guides&quot;&gt;Other Objective-C Style Guides&lt;/h1&gt;

&lt;p&gt;If ours doesn’t fit your tastes, have a look at some other style guides:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/RobotsAndPencils/objective-c-style-guide&quot;&gt;Robots &amp;amp; Pencils&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/NYTimes/objective-c-style-guide&quot;&gt;New York Times&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml&quot;&gt;Google&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/github/objective-c-conventions&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://trac.adium.im/wiki/CodingStyle&quot;&gt;Adium&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/soffes/812796&quot;&gt;Sam Soffes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cocoadevcentral.com/articles/000082.php&quot;&gt;CocoaDevCentral&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html&quot;&gt;Luke Redpath&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cimgf.com/zds-code-style-guide/&quot;&gt;Marcus Zarra&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 10 Nov 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/11/10/Raywenderlich-Objective-C-style-guide-CN.html</link>
        <guid isPermaLink="true">/cn/2014/11/10/Raywenderlich-Objective-C-style-guide-CN.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>如何快速的切换Mac系统的网络配置</title>
        <description>&lt;h1 id=&quot;mac&quot;&gt;如何快速的切换Mac系统的网络配置&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;由于国内网络环境恶劣，在日常使用中，我经常会面临如下情况&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;访问Google, Youtube等境外网站需要使用&lt;code&gt;曲径&lt;/code&gt;等自动代理配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;或者最近经常出现的DNS服务污染，比较严重的情况连taobao搜索都不可使用，或者在使用Appstore下载更新时，使用 114, 08 , openDNS等手动配置更为靠谱&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时候却造成我访问国内网站（视频网站会比较明显）速度下降，所以需要切换回运营提供的DNS（此DNS一般能与114，08等DNS有几十到几百望毫秒的差距）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;p&gt;所以每当感觉上网不畅时，一般都需要点开&lt;code&gt;系统偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;网络&lt;/code&gt;-&amp;gt;&lt;code&gt;高级&lt;/code&gt;-&amp;gt;&lt;code&gt;DNS&lt;/code&gt; or &lt;code&gt;代理&lt;/code&gt;等设置，还需要额外的从一些记录软件中提取相应的配置参数&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解决办法：&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;系统偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;网络&lt;/code&gt; 此页面上有一个位置，选择&lt;code&gt;编辑位置&lt;/code&gt;后点击下面的&lt;code&gt;+&lt;/code&gt;，即设立一种新的网络环境。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用：&lt;/h2&gt;

&lt;p&gt;OK，此种方法最赞的就是只用点击桌面左上角的小苹果&lt;code&gt;&lt;/code&gt;-&amp;gt;&lt;code&gt;位置&lt;/code&gt;进行切换即可。
####缺点：网络会切断一会儿。&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Nov 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/11/03/SwitchInternetSetting-CN.html</link>
        <guid isPermaLink="true">/cn/2014/11/03/SwitchInternetSetting-CN.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>Ruby Study Memo</title>
        <description>&lt;p&gt;Leran this at www.codecademy.com. Great online course.I picked up some key word from this lession for memo.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&quot;basic&quot;&gt;Basic&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;There’s always more than one way to do something in Ruby.&lt;/li&gt;
  &lt;li&gt;Everything in Ruby is an Object.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;input&quot;&gt;Input&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;variable = gets.chomp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;chomp&lt;/code&gt; removes that extra line.&lt;/p&gt;

&lt;h2 id=&quot;operation&quot;&gt;Operation&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;create with empty hash&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;file = {}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;need space between variable and operation&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Error: a++
Fine: a += 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;control-flow&quot;&gt;Control Flow&lt;/h2&gt;

&lt;h3 id=&quot;unless--ifvar&quot;&gt;unless == if(!var)&lt;/h3&gt;

&lt;h2 id=&quot;loops--iterators&quot;&gt;Loops &amp;amp; Iterators&lt;/h2&gt;

&lt;h3 id=&quot;until&quot;&gt;until&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 0
until i == 6
  i += 1
end
puts i
# ==&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;loop&quot;&gt;Loop&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;i = 20
loop do
  i -= 1
  print &quot;#{i}&quot;
  break if i &amp;lt;= 0
end
#==&amp;gt;191817161514131211109876543210
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;code&gt;next&lt;/code&gt; keywords can be used to skip over certain steps in the loop.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;i = 20
loop do
  i -= 1
  next if i % 2 == 1
  print &quot;#{i}&quot;
  break if i &amp;lt;= 0
end
#==&amp;gt;181614121086420
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;inclusive-and-exclusive-ranges&quot;&gt;Inclusive and Exclusive Ranges&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;1..15&lt;/code&gt; not include 15&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;1...15&lt;/code&gt; inlcude 15 &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iterator&quot;&gt;Iterator&lt;/h2&gt;

&lt;p&gt;can apply an expression to each element of an object.
~~~
object.each { |item| # Do something }
~~~&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.times&lt;/code&gt; methods is like a super compact &lt;code&gt;for&lt;/code&gt; loop: it can perform a task on each item in a object a specified number of times.
~~~
10.times { print “Chunky bacon!” }
~~~&lt;/p&gt;

&lt;h2 id=&quot;blockproclambda&quot;&gt;Block,Proc,Lambda&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Block&lt;/code&gt;: A Ruby block is just a bit of code that can be excuted.&lt;/p&gt;

&lt;h3 id=&quot;bolck&quot;&gt;Bolck&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;
my_nums = [1,2,3]
#.collection
my_nums.collection { |num| num ** 2 }
# return [1,4,9]
my_nums.collection! { |num| num ** 2 }
# return [1,4,9] &amp;amp;&amp;amp; my_nums == [1,4,9]


#.each
[1, 2, 3].each do |num|
  puts num
end
# ==&amp;gt; Prints 1, 2, 3 on separate lines
[1, 2, 3].each { |num| puts num }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;yied&quot;&gt;Yied&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def block_test
  puts &quot;We&#39;re in the method!&quot;
  puts &quot;Yielding to the block...&quot;
  yield
  puts &quot;We&#39;re back in the method!&quot;
end

block_test { puts &quot;&amp;gt;&amp;gt;&amp;gt; We&#39;re in the block!&quot; }


def double(n)
    puts &quot;Ori input is #{n}&quot;
    yield(n)
end

double(2) { |n| puts n *2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;proc&quot;&gt;Proc&lt;/h3&gt;
&lt;p&gt;Procs are easy to define! You just call &lt;code&gt;Proc.new&lt;/code&gt; and pass in the block you want to save.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Procs are full-fledged object.&lt;/li&gt;
  &lt;li&gt;This prevents you from haveing to retype the contents of your block every time you need to execute a particular bit of code.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;multiples_of_3 = Proc.new do |n|
  n % 3 == 0
end

(1..100).to_a.select(&amp;amp;multiples_of_3)

multiples_of_3.call
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lambda&quot;&gt;Lambda&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lambda { |param| block }

lambda { puts &quot;Hello!&quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;lambda-vs-proc&quot;&gt;Lambda VS. Proc&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;A lambda checks the number of arguments passed to it , while a proc does not. This means that a lambda will throw an error if you pass it the worng number of arguments, whereas a proc will ignore unexpected arguments and assign &lt;code&gt;nil&lt;/code&gt; to any that are missing.&lt;/li&gt;
  &lt;li&gt;When a lambda returns , it passes control back to the calling methods; when a proc returns, it does so immediately, without going back to the calling methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;class&quot;&gt;Class&lt;/h1&gt;

&lt;h3 id=&quot;create-a-class&quot;&gt;Create a class&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Message
    @@messages_sent = 0
    def initialize(from, to)
        @from = from
        @to = to
        @@messages_sent += 1
    end
end

my_message = Message.new(&quot;wing.of.war&quot;,&quot;Zhangejue&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if you want to end a Ruby statement without going to a new line, you can just type a semicolon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Monkey
end

to 

class Monkey;end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;set--get&quot;&gt;Set &amp;amp; Get&lt;/h3&gt;

&lt;p&gt;That &lt;code&gt;name=&lt;/code&gt; might look funny, but you’re allowed to put an &lt;code&gt;=&lt;/code&gt; sign in a methods name.
~~~
def name
  @name
end&lt;/p&gt;

&lt;p&gt;def name=(value)
  @name = value
end&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*equal*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;attr_reader :name
attr_writer :job
attr_accessor :job
~~~&lt;/p&gt;

&lt;h2 id=&quot;class-variable&quot;&gt;Class Variable&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;We can create class variable by starting a variable name with two @&lt;/li&gt;
  &lt;li&gt;Only one copy of a class variable shared by all instances of a class.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyClass
	@@class_variable
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;class variable should use a class method to grab it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;inheritance&quot;&gt;Inheritance&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ChildClass &amp;lt; FatherClass
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;ChildClass is called: &lt;strong&gt;derived class&lt;/strong&gt; Or &lt;strong&gt;subclasss&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;FatherClass is called: &lt;strong&gt;parent&lt;/strong&gt; or &lt;strong&gt;superclass&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;derived class&lt;/strong&gt; can only have one &lt;strong&gt;superclass&lt;/strong&gt;, not support &lt;strong&gt;multiple inheritance&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class DerivedClass &amp;lt; Base
  def some_method
    super(optional args)
      # Some stuff
    end
  end
end

class Email&amp;lt;Message
    def initialize(from, to)
        super
    end
end

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;publicprivate&quot;&gt;Public&amp;amp;Private&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Note that everything after the &lt;strong&gt;public&lt;/strong&gt; keyword through the &lt;strong&gt;end&lt;/strong&gt; of the class definition will now be public unless we say otherwise.&lt;/li&gt;
  &lt;li&gt;Another way to say this is that the method cannot be called with an explicit receiver.&lt;/li&gt;
  &lt;li&gt;In order to access private information, we have to create public methods that know how to get it.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;module&quot;&gt;Module&lt;/h1&gt;

&lt;p&gt;You can think of a &lt;strong&gt;Module&lt;/strong&gt; as a toolbox that contains a set of methods and constants.&lt;/p&gt;

&lt;p&gt;One of the main purposes of modules is to seprate methods and constants into named spaces. That is called &lt;code&gt;namespacing&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It dosent’t make sense to include variables in modules, since variables change.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module MyLibrary
    FAVE_BOOK = &quot;Harry porter&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;Math::PI&lt;/code&gt; and &lt;code&gt;Circle::PI&lt;/code&gt;, This is called the &lt;strong&gt;scope resolution operator&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inlcude-a-module&quot;&gt;inlcude a module…&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Angle
  include Math
  attr_accessor :radians
  
  def initialize(radians)
    @radians = radians
  end
  
  def cosine
    cos(@radians)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;mixin&quot;&gt;Mixin&lt;/h2&gt;

&lt;p&gt;When a module is used to mix addtional behavior and information into a class, it’s called &lt;strong&gt;mixin&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;include&lt;/code&gt; mixed a module’s methods in at the instance level.&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;extend&lt;/code&gt; keyword mixes a module’s methods at the &lt;code&gt;class&lt;/code&gt; level.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 25 Oct 2014 00:00:00 +0800</pubDate>
        <link>/ruby/2014/10/25/Ruby_Study-EN.html</link>
        <guid isPermaLink="true">/ruby/2014/10/25/Ruby_Study-EN.html</guid>
        
        
        <category>ruby</category>
        
      </item>
    
      <item>
        <title>ACGArt DownLoader</title>
        <description>&lt;h3 id=&quot;repositoryacgartimagebatchdonehttpsgithubcomwing-of-waracgartimagebatchdone&quot;&gt;&lt;a href=&quot;https://github.com/Wing-Of-War/ACGArtImageBatchDone&quot;&gt;Repository:ACGArtImageBatchDone&lt;/a&gt;&lt;/h3&gt;

&lt;h2 id=&quot;project-origin&quot;&gt;Project Origin&lt;/h2&gt;

&lt;p&gt;Last Year I bought an intersting iOS application named ACG ART&lt;a href=&quot;https://itunes.apple.com/cn/app/acg-art-er-ci-yuan-dong-man/id577006740?mt=8&quot;&gt;APP Store link&lt;/a&gt;.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;As you can see, it will provide large number of anime pictures. It’s really briliant.&lt;/p&gt;

&lt;p&gt;But you know mobile phone it’s not a work platform , it is hard to manage and pick the image from the application.(Connection and download are not fast..)
So, I spent two days worktout this little thing to batch download.&lt;/p&gt;

&lt;h2 id=&quot;wow-i-cant-stop-it&quot;&gt;WoW~ I can’t stop it!&lt;/h2&gt;

&lt;h3 id=&quot;downloading&quot;&gt;DownLoading..&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/56becbc4gw1eka8cay4vkj20it0ca436.jpg&quot; alt=&quot;DownLoading..&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pictures&quot;&gt;Pictures&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/56becbc4gw1eka8cable3j20qr0u7q90.jpg&quot; alt=&quot;Pictures&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;please-tell-me&quot;&gt;Please Tell Me&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;If you like it &lt;/li&gt;
  &lt;li&gt;If you have better ideal to impove it &lt;/li&gt;
  &lt;li&gt;If this offend you&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 13 Sep 2014 00:00:00 +0800</pubDate>
        <link>/python/2014/09/13/ACGArt-EN.html</link>
        <guid isPermaLink="true">/python/2014/09/13/ACGArt-EN.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>Cocoapods进阶教程</title>
        <description>&lt;p&gt;作为第一篇正式技术性Blog，主要是为了记录最近研究的Cocoapods在项目中的使用（虽然也还不是特别懂：P）。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h4 id=&quot;section&quot;&gt;文章说明：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可能会有点啰嗦，想详细点，个人比较健忘，重点会标明&lt;/li&gt;
  &lt;li&gt;有些问题我也没研究明白，但以可用为主&lt;/li&gt;
  &lt;li&gt;欢迎指教，Email: wing.of.war.1980th@gmail.com&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cocoapods的教程一般都是基本的入门（大约是如我下图所示的Step2)，官方文档感觉对于新手也不够友好（至少像我这样的半桶水研究了两个晚上），所以一半教学一半记录吧。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;此文的结构如下图步骤所示：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/Cocoapods%20article%20%20structure.jpg&quot; alt=&quot;Cocoapods article  structure&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;正文——像一个普通工程开始&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Step1: 创建一个新工程&lt;/li&gt;
  &lt;li&gt;Step2: 通过CocoaPods导入几个常见框架（当然，说明项目中不会导入那么多，将以AFNetworking为例）
&lt;strong&gt;Step 2.2&lt;/strong&gt;将说明如果卸载CocoaPods&lt;strong&gt;（非常有用）&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Step3: 创建一个个人类库（这将不会出现于Cocoapods的官方类库列表）。
&lt;strong&gt;Step 3.1&lt;/strong&gt; 是通过Cocoapods创建的一个类库，保存与管理于Github上，在自己的项目中进行引用。便于团队的协作开发。
&lt;strong&gt;Step 3.2&lt;/strong&gt;是在项目中建立一个私有类库，引用方式为相对路径，&lt;strong&gt;好处是如果项目是私有的，将可以一起同项目保密和同步&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Step4：工程需要进行扩展，在一个workspace下建立了多个target或者是导入了多个project，&lt;strong&gt;重点是Podfile的配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后本文的内容就会以上面的步骤的逐步进行，读者可以根据自身的需要来选择章节。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;几个关键点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一个很好的&lt;a href=&quot;http://code4app.com/article/cocoapods-install-usage&quot;&gt;安装教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;多个项目工程使用同一个Cocoapods的Podfile的编写&lt;/li&gt;
  &lt;li&gt;*.podspec文件的编写&lt;/li&gt;
  &lt;li&gt;使用CocoaPoads对自身项目中的私有类库进行管理&lt;/li&gt;
  &lt;li&gt;从Github导入个人类库&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Wing-Of-War/CocoaPods_Demo&quot;&gt;Demo项目&lt;/a&gt;，&lt;a href=&quot;https://github.com/Wing-Of-War/MyPrivateLibs&quot;&gt;Demo框架&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step2-cocoapoads&quot;&gt;Step2 工程导入CocoaPoads&lt;/h2&gt;

&lt;p&gt;虽然是进阶教程，但我还是把基本的操作和常用的方法写一下，如果大家有更简便的方法可以我指点一下。&lt;/p&gt;

&lt;p&gt;在桌面上，我新建了一个文件夹为将来的整体项目&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir CocoaPods_Demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在此文件夹下，我建立了一个iPhone项目，命名为MyProject
进入到此项目下，pod初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd MyProject
pod init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在此文件夹下创建一个podfile文件，编辑podfile的内容如下，添加一个AFNetworking框架（非常好的类库示例，研究了很多）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Uncomment this line to define a global platform for your project
# platform :ios, &quot;6.0&quot;

target &quot;MyProject&quot; do
pod &quot;AFNetworking&quot; 
end


target &quot;MyProjectTests&quot; do

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开MyProject，此后使用的将是MyProject.xcworkspace这种以.xcworkspace为后缀的工作空间。在ViewController中我们可以尝试导入一下&amp;lt;AFNetworking/…&amp;gt;，如下图所示提示相关的头文件，则导入的框架AFNetworking工作正常。
&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/AFNetworking%20import.png&quot; alt=&quot;AFNetworking import&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/CocoaPods/guides.cocoapods.org/issues/14&quot;&gt;补充:pod install和pod update命令的区别&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;
* pod install作为初次安装
* pod update为变更podfile和导入类库升级时使用&lt;/p&gt;

&lt;h3 id=&quot;step21-cocoapods&quot;&gt;Step2.1 类库移除&amp;amp;CocoaPods卸载&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;类库移除&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;在podfile文件中移除相应的类库引入行，然后执行&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将自动移除多余的框架&lt;/p&gt;

&lt;h4 id=&quot;cocoapods&quot;&gt;CocoaPods卸载&lt;/h4&gt;

&lt;p&gt;转自&lt;a href=&quot;http://blog.csdn.net/freedom2028/article/details/10244819&quot;&gt;《从工程中删除Cocoapods》&lt;/a&gt;:
* 删除工程文件夹下的Podfile、Podfile.lock及Pods文件夹
* 删除xcworkspace文件
* &lt;strong&gt;&lt;em&gt;使用xcodeproj文件打开工程，删除Frameworks组下的Pods.xcconfig及libPods.a引用&lt;/em&gt;&lt;/strong&gt;
* 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/CocoaPods%20Delete.png&quot; alt=&quot;CocoaPods Delete&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以上几点中，第三点中删除xcconfig应该是核心点，它是Cocoapods链接各个类库的关键。经常有可能Podfile写错后，生成多个xcconfig造成工程的头文件引入编译错误。此时可以先用此方法进行一次卸载后，重新初始化Cocoapods。&lt;/p&gt;

&lt;h2 id=&quot;step3-&quot;&gt;Step3 创建个人类库&lt;/h2&gt;

&lt;p&gt;创建类库的pod命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod lib create &quot;MyPrivateLibs&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MyPrivateLibs%20Create.png&quot; alt=&quot;CocoaPods library create&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建是使用的Cocoapods的模板类，几个选项默认就好。进入此文件夹，
&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MyPrivateLibs%20files.png&quot; alt=&quot;MyPrivateLibs files&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Example是模板中创建的测试工程项目，Example下已经自带podfile并且在运行install命令后，会自动导入这个类库，可以很方便的进行编写与测试；&lt;/li&gt;
  &lt;li&gt;MyPrivateLibs.podspec&lt;strong&gt;非常重要&lt;/strong&gt;，几乎是整个类库用于导入与存储结构的核心，不过目前步骤使用默认即可；&lt;/li&gt;
  &lt;li&gt;Pod在默认包含Assets和Classes两个文件夹，一个用于存放图片，一个用于存放框架文件，在使用黑夜MyPrivateLibs.podspec的情况下，按此分类放好类库文件。&lt;/li&gt;
  &lt;li&gt;LICENSE和README.md顾名思义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在我们在Example里的项目中，添加一个类别（可以向类别扩展属性），命名为AssociatedObjects
.h文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface NSObject (AssociatedObjects)
- (void)associateValue:(id)value withKey:(void *)key;
- (id)associatedValueForKey:(void *)key;
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;.m文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &quot;NSObject+AssociatedObjects.h&quot;
#import &amp;lt;objc/runtime.h&amp;gt;
@implementation NSObject (AssociatedObjects)
- (void)associateValue:(id)value withKey:(void *)key
{
    objc_setAssociatedObject(self, key, value, OBJC_ASSOCIATION_RETAIN);
}
- (id)associatedValueForKey:(void *)key
{
    return objc_getAssociatedObject(self, key);
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写一个简单的测试方法，向一个NSArray中关联了一个日期，十秒后取出，一切正常工作～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MyPrivateLibs%20Test.png&quot; alt=&quot;MyPrivateLibs Test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下是我目前自己的方法&lt;/p&gt;

&lt;p&gt;1、把&lt;code&gt;NSObject+AssociatedObjects.h&lt;/code&gt;和&lt;code&gt;NSObject+AssociatedObjects.m&lt;/code&gt;两个文件移动到&lt;code&gt;/MyPrivateLibs/Pod/Classes&lt;/code&gt;下
2、在Example中运行
~~~
pod update命令
~~~
3、打开Example中的测试项目，删除原项目中的.h和.m文件（当然，当前已经显示为文件无法找寻状态）然后在引用地方导入&lt;code&gt;&amp;lt;MyPrivateLibs/NSObject+AssociatedObjects.h&amp;gt;&lt;/code&gt;
4、如果测试正常，则说明此类库建立正常&lt;/p&gt;

&lt;h3 id=&quot;step31-github&quot;&gt;Step3.1 导入Github类库&lt;/h3&gt;

&lt;p&gt;根据之前的步骤，将MyPrivateLibs提交到Github，我的
&lt;a href=&quot;https://github.com/Wing-Of-War/MyPrivateLibs&quot;&gt;MyPrivateLibs&lt;/a&gt;:https://github.com/Wing-Of-War/MyPrivateLibs
如果为了方便，则可以直接引用我这个框架&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果是要直接引用Github上的类库，则务必将 .podspec文件放在类库的最上层目录中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回到&lt;code&gt;CocoaPods_Demo/MyProject/&lt;/code&gt;中，修改Podfile如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;target &quot;MyProject&quot; do
pod &quot;AFNetworking&quot; 
pod &quot;MyPrivateLibs&quot;, github =&amp;gt; &quot;https://github.com/Wing-Of-War/MyPrivateLibs&quot;
end


target &quot;MyProjectTests&quot; do

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后install一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MyPrivateLibs%20import.png&quot; alt=&quot;MyPrivateLibs import&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看见Installing MyPrivateLibs (0.1.0）已经正常安装，打开MyProject.xcworkspace，在Pod项目中，MyPrivateLibs和两个类库文件出现。然后测试一下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/After%20Import%20MyPrivateLibs%20Test.png&quot; alt=&quot;After Import MyPrivateLibs Test&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一切工作正常，说明导入和类库都是正常的。&lt;/p&gt;

&lt;p&gt;OK，接下来更多干货马上出现～&lt;/p&gt;

&lt;h3 id=&quot;step32-&quot;&gt;Step3.2 导入本地类库&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;需求的来源&lt;/strong&gt;———我们公司的项目是保存于Github上的一个私有repositories中，所以此项目中写的一些框架当然不能随便公开啦。
但为了管理方便和自己使用方法（只有我一个人在弄这个项目），我希望把其中的一部分&lt;strong&gt;固定核心代码&lt;/strong&gt;从原项目中独立出来，做为一个私有内部框架，这也是为Step4做准备，所以折腾这个步骤了很久。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;创建简单的框架&lt;/h4&gt;

&lt;p&gt;在MyProject中，我创建了一个用于转换RFC3339的时间与字符串的转换方法类。&lt;/p&gt;

&lt;p&gt;MyTimeTool.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface MyTimeTool : NSObject

+ (NSDate *)rfc3339DateFormatterParse:(NSString *)string isExtend:(BOOL)isExtend;
+ (NSString *)rfc3339DateFormatterGenerate:(NSDate *)date isExtend:(BOOL)isExtend;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MyTimeTool.m，本来是自己写的方法，后来根据Apple官方文档改的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
+ (NSString *)rfc3339DateFormatterGenerate:(NSDate *)date isExtend:(BOOL)isExtend
{
    static NSDateFormatter *dateFormatter = nil;
    if (!dateFormatter) {
        dateFormatter = [[NSDateFormatter alloc] init];
        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];
        [dateFormatter setLocale:enUSPOSIXLocale];
        [dateFormatter setTimeZone:[NSTimeZone timeZoneWithAbbreviation:@&quot;UTC&quot;]];
        [dateFormatter setDateFormat:@&quot;yyyyMMdd&#39;T&#39;HHmmss&#39;Z&#39;&quot;];
    }
    //    NSLog(@&quot;rfc3339DateFormatterGenerate is %@, originDate is %@&quot;,[dateFormatter stringFromDate:date] , date);
    return [dateFormatter stringFromDate:date];
}


+ (NSDateFormatter *)getRfc3339ExtendFormatter
{
    static NSDateFormatter *rfc3339ExtendFormatter = nil;
    if (!rfc3339ExtendFormatter) {
        rfc3339ExtendFormatter = [[NSDateFormatter alloc] init];
        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];
        [rfc3339ExtendFormatter setLocale:enUSPOSIXLocale];
        [rfc3339ExtendFormatter setDateFormat:@&quot;yyyy&#39;-&#39;MM&#39;-&#39;dd&#39;T&#39;HH&#39;:&#39;mm&#39;:&#39;ss&#39;.&#39;SSS&#39;Z&#39;&quot;];
        [rfc3339ExtendFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
    }
    return rfc3339ExtendFormatter;
}

+ (NSDateFormatter *)getRfc3339ShortFormatter
{
    static NSDateFormatter *rfc3339ShortFormatter = nil;
    if (!rfc3339ShortFormatter) {
        rfc3339ShortFormatter = [[NSDateFormatter alloc] init];
        NSLocale *enUSPOSIXLocale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;];
        [rfc3339ShortFormatter setLocale:enUSPOSIXLocale];
        [rfc3339ShortFormatter setDateFormat:@&quot;yyyyMMdd&#39;T&#39;HHmmss&#39;Z&#39;&quot;];
        [rfc3339ShortFormatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
    }
    return rfc3339ShortFormatter;    
}

+ (NSDate *)rfc3339DateFormatterParse:(NSString *)string isExtend:(BOOL)isExtend
{
    NSDateFormatter *parseFormatter = nil;
    if (isExtend) {
        parseFormatter = [self getRfc3339ExtendFormatter];
    }else
    {
        parseFormatter = [self getRfc3339ShortFormatter];
    }
    NSDate *result = [parseFormatter dateFromString:string];
    //    NSLog(@&quot;rfc3339DateFormatterParse result is %@, origin stirng is %@&quot;, result, string );
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就以这两个文件为例创建一个本地类库&lt;/p&gt;

&lt;p&gt;从终端进入到CocoaPods_Demo文件下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod lib create MyLocalLib

..............................

Would you like to have a demo for your library? [ Yes / No ]
 &amp;gt; NO

Which testing frameworks will you use? [ Specta / Kiwi ]
 &amp;gt; 
specta
Would you like to do view based testing? [ Yes / No ]
 &amp;gt; NO

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之前的过程是类似的，但我们可以简单点，移植过来的类库都是已经在原有项目中测试过的。&lt;/p&gt;

&lt;p&gt;为了丰富一下这个本地类库，我们将会把MyPrivate项目里的框架也一并移植过来。&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;MyLocalLib&lt;/code&gt;目录下，分别创建一个&lt;code&gt;MyTimeTool&lt;/code&gt;和&lt;code&gt;MyCategory&lt;/code&gt;两个文件夹。将MyPrivate项目中的两个文件放入&lt;code&gt;MyCategory&lt;/code&gt;中，将&lt;code&gt;MyTimeTool.h&lt;/code&gt;和&lt;code&gt;MyTimeTool.m&lt;/code&gt;文件放入MyTimeTool中，并且可以删除&lt;code&gt;Pod&lt;/code&gt;和&lt;code&gt;Example&lt;/code&gt;两个文件夹，让我们的Lib看起来更纯粹一点。&lt;/p&gt;

&lt;h4 id=&quot;podspec&quot;&gt;编写. podspec文件&lt;/h4&gt;
&lt;p&gt;因为是ruby的语法，虽然我不懂，但在参考了其它几个比较成熟的Cocoapods后，写出来个配置文件也是能够work的。先把写好的配置文件粘上来，再解释一下相关的字段。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;请注意所有的编写一定要不要Mac系统自带的文本处理器，经常会将&lt;code&gt;&#39;&lt;/code&gt;打成&lt;code&gt;‘&lt;/code&gt;。推荐使用&lt;code&gt;Sumblime&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Pod::Spec.new do |s|
  s.name             = &quot;MyLocalLib&quot;
  s.version          = &quot;0.1.0&quot;
  s.summary          = &quot;A short description of MyLocalLib.&quot;
  s.description      = &amp;lt;&amp;lt;-DESC
                       An optional longer description of MyLocalLib

                       * Markdown format.
                       * Don&#39;t worry about the indent, we strip it!
                       DESC
  s.homepage         = &quot;https://github.com/&amp;lt;GITHUB_USERNAME&amp;gt;/MyLocalLib&quot;
  # s.screenshots     = &quot;www.example.com/screenshots_1&quot;, &quot;www.example.com/screenshots_2&quot;
  s.license          = &#39;MIT&#39;
  s.author           = { &quot;wing.of.war.1980th&quot; =&amp;gt; &quot;wing.of.war.1980th@gmail.com&quot; }
  s.source           = { :git =&amp;gt; &quot;https://github.com/&amp;lt;GITHUB_USERNAME&amp;gt;/MyLocalLib.git&quot;, :tag =&amp;gt; s.version.to_s }
  # s.social_media_url = &#39;https://twitter.com/&amp;lt;TWITTER_USERNAME&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分是此类库的对外信息，很容易修改，&lt;em&gt;s.name&lt;/em&gt;里的类库名称不要拼错，是与podfile中的引用名称所对应的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  s.ios.deployment_target = &#39;7.0&#39;
  s.osx.deployment_target = &#39;10.9&#39;
  s.requires_arc = true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此部分是类库的使用平台信息，我这里不仅设置了iOS平台，也设置了Mac OS平台。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  s.public_header_files = &#39;*.h&#39;
  s.source_files = &#39;MyLocalLibHeader.h&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有此文件，将会做为此类库的公共头文件。这样在框架导入的时候，使用者可以在自己&lt;code&gt;MyProject-Prefix.pch&lt;/code&gt;文件中直接引入此文件。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;重点部分&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;  s.subspec &#39;MyCategory&#39; do |ss|
        ss.source_files = &#39;MyCategory/*.{h,m}&#39;
        ss.dependency &#39;FMDB&#39;
        # s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;
  end

  s.subspec &#39;DataCenter&#39; do |ss|
        ss.source_files = &#39;MyTimeTool/*.{h,m}&#39;
        # ss.dependency &#39;AFNetworking&#39;
  end

  # s.public_header_files = &#39;Pod/Classes/**/*.h&#39;
  # s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;
  # s.dependency &#39;AFNetworking&#39;, &#39;~&amp;gt; 2.3&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;s.subspec ‘MyCategory’ do |ss|
 应该是创建一个子模块，在项目中的体现是创建了一个文件夹，在此模块下的文件将保存于此文件夹下&lt;/li&gt;
  &lt;li&gt;ss.source_files = ‘MyCategory/*.{h,m}’ 指定这些源文件的路径，这个是MyCategory模块，所以我们指向&lt;code&gt;MyCategory/&lt;/code&gt;文件夹下的所有源文件，当然也可以直接指定具体文件，但肯定不如这种遍历的形式方便； &lt;/li&gt;
  &lt;li&gt;ss.dependency是依赖其它的Cocoapods的类库，这里为了演示，依赖了&lt;code&gt;FMDB&lt;/code&gt;这个Sqlite处理框架&lt;/li&gt;
  &lt;li&gt;s.frameworks应该是依赖的apple框架，我们这里都写的简单类库，就不再引用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OK，准备工作做完后，开始导入。这是我当前项目的文件夹结构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/file%20struct.png&quot; alt=&quot;file struct&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;如果是用路径引用，则podfile中的路径一定要能指向类库的.podspec文件&lt;/em&gt;&lt;/strong&gt;
所以，将podfile更改为如下
~~~
target “MyProject” do
	pod “AFNetworking” 
    pod “MyLocalLib”, :path =&amp;gt; “../MyLocalLib”
end
~~~&lt;/p&gt;

&lt;p&gt;&lt;code&gt;../MyLocalLib&lt;/code&gt;表示的路径为上一级目录下的&lt;code&gt;MyLocalLib&lt;/code&gt;文件，此文件下包括了.podspec&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/import%20LocalLib.png&quot; alt=&quot;import LocalLib&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不仅安装了MyLocalLib框架，并且通过&lt;code&gt;ss.dependency &#39;FMDB&#39;&lt;/code&gt;导入了&lt;code&gt;FMDB&lt;/code&gt;类库。打开工程文件，如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/Mylocallib%20insatll.png&quot; alt=&quot;Mylocallib insatll&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过GitHub安装的MyPrivateLib框架已经移除&lt;/li&gt;
  &lt;li&gt;MyLocalLib已经导入可以正常使用&lt;/li&gt;
  &lt;li&gt;MyLocalLib保持了其原文件结构&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;step4-cocoapoads&quot;&gt;Step4 工作空间使用CocoaPoads&lt;/h2&gt;

&lt;p&gt;最后一个部分，既然我项目的核心功能部分独立出来，那我在多个平台上都可以用。所以我们在&lt;code&gt;MyProject\MyProject.xcworkspace&lt;/code&gt;的工作空间下添加了一个Mac项目&lt;code&gt;MyMacProject&lt;/code&gt;,此项目也将引用我们之前使用的&lt;code&gt;MyLocalLib&lt;/code&gt;和&lt;code&gt;AFNetworking&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为了增加一点配置文件编写难度和保持项目的平级性，我们的文件结构是如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MacProject%20file%20structure.png&quot; alt=&quot;MacProject file structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Podfile&lt;/code&gt;的配置文件是位于&lt;code&gt;MyProject&lt;/code&gt;下的。所以根据之前在导入&lt;code&gt;MyLocalLib&lt;/code&gt;时所写的配置也会有些技巧。根据多处查找资料和研究别人的类库，是需要根据每一个工程中的Targe来建立与CocoaPods的关联，每一个target都要把相应的&lt;code&gt;*.xcodeproj&lt;/code&gt;的位置在其中进行描述。同时我也对&lt;code&gt;target&lt;/code&gt;所使用的平台进行了描述，免得在导入一些类库时引起一些版本上的限制。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;workspace &#39;MyProject&#39;

target &#39;MyProject&#39; do
    platform :ios, &#39;7.0&#39;
	pod &quot;AFNetworking&quot; 
    pod &quot;MyLocalLib&quot;, :path =&amp;gt; &quot;../MyLocalLib&quot;
	xcodeproj &#39;MyProject.xcodeproj&#39;
end

target &#39;MyMacProject&#39; do
    platform :osx, &#39;10.9&#39;
	pod &quot;AFNetworking&quot; 
    pod &quot;MyLocalLib&quot;, :path =&amp;gt; &quot;../MyLocalLib&quot;
	xcodeproj &#39;../MyMacProject/MyMacProject.xcodeproj&#39;
end

target &quot;MyProjectTests&quot; do

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;MyProject\&lt;/code&gt;目录下运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;命令。完成后，再打开&lt;code&gt;MyProject.xcworkspace&lt;/code&gt;工作空间，已经如下图所示，在MyMacProject中导入&lt;code&gt;MyLocalLib&lt;/code&gt;类库，一切正常～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Wing-Of-War/wing-of-war.github.com/master/_postsImages/2014/08/MacProject%20import%20MyLocalLib.png&quot; alt=&quot;MacProject import MyLocalLib&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Aug 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/08/10/Cocoapods-Research-CN.html</link>
        <guid isPermaLink="true">/cn/2014/08/10/Cocoapods-Research-CN.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
      <item>
        <title>My first blog in github</title>
        <description>&lt;h1 id=&quot;my-first-blog-in-github&quot;&gt;My first blog in github&lt;/h1&gt;

&lt;p class=&quot;meta&quot;&gt;9 August 2014 - BeiJing&lt;/p&gt;

&lt;p&gt;I had set serval target to myself:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Jekyll is not easy to use, but very fascinating, I want to good to use it.&lt;/li&gt;
  &lt;li&gt;Each post of this blog will be published in Chinese and English.(I’m exercising my English writing skills)&lt;/li&gt;
  &lt;li&gt;Improve the web site every week.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 09 Aug 2014 00:00:00 +0800</pubDate>
        <link>/en/2014/08/09/FirstPost-EN.html</link>
        <guid isPermaLink="true">/en/2014/08/09/FirstPost-EN.html</guid>
        
        
        <category>en</category>
        
      </item>
    
      <item>
        <title>GitHub 上的第一贴</title>
        <description>&lt;h1 id=&quot;github-&quot;&gt;GitHub 上的第一贴&lt;/h1&gt;

&lt;p class=&quot;meta&quot;&gt;9 August 2014 - BeiJing&lt;/p&gt;

&lt;p&gt;我在这里设立了几个目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过Jekyll来打造Github上的技术博客，学习与使用一些Html技术&lt;/li&gt;
  &lt;li&gt;每一遍技术博客都是中英文双语&lt;/li&gt;
  &lt;li&gt;保持更新量，并且争取投稿&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps2014-8-20&quot;&gt;PS:补于2014-8-20，文章分类后&lt;/h3&gt;
</description>
        <pubDate>Sat, 09 Aug 2014 00:00:00 +0800</pubDate>
        <link>/cn/2014/08/09/FirstPost-CN.html</link>
        <guid isPermaLink="true">/cn/2014/08/09/FirstPost-CN.html</guid>
        
        
        <category>cn</category>
        
      </item>
    
  </channel>
</rss>
