<p>Leran this at www.codecademy.com. Great online course.I picked up some key word from this lession for memo.</p>

<!-- more -->

<h1 id="basic">Basic</h1>

<ol>
  <li>There’s always more than one way to do something in Ruby.</li>
  <li>Everything in Ruby is an Object.</li>
</ol>

<h2 id="input">Input</h2>

<pre><code>variable = gets.chomp
</code></pre>
<p><code>chomp</code> removes that extra line.</p>

<h2 id="operation">Operation</h2>

<ul>
  <li>create with empty hash</li>
</ul>

<pre><code class="language-ruby">file = {}
</code></pre>

<ul>
  <li>need space between variable and operation</li>
</ul>

<pre><code class="language-ruby">Error: a++
Fine: a += 1 
</code></pre>

<h2 id="control-flow">Control Flow</h2>

<h3 id="unless--ifvar">unless == if(!var)</h3>

<h2 id="loops--iterators">Loops &amp; Iterators</h2>

<h3 id="until">until</h3>
<pre><code>i = 0
until i == 6
  i += 1
end
puts i
# ==&gt; 6
</code></pre>

<h3 id="loop">Loop</h3>
<pre><code>i = 20
loop do
  i -= 1
  print "#{i}"
  break if i &lt;= 0
end
#==&gt;191817161514131211109876543210
</code></pre>
<ul>
  <li>The <code>next</code> keywords can be used to skip over certain steps in the loop.</li>
</ul>

<pre><code>i = 20
loop do
  i -= 1
  next if i % 2 == 1
  print "#{i}"
  break if i &lt;= 0
end
#==&gt;181614121086420
</code></pre>

<h3 id="inclusive-and-exclusive-ranges">Inclusive and Exclusive Ranges</h3>

<ul>
  <li><code>1..15</code> not include 15</li>
  <li><code>1...15</code> inlcude 15 </li>
</ul>

<h2 id="iterator">Iterator</h2>

<p>can apply an expression to each element of an object.
~~~
object.each { |item| # Do something }
~~~</p>

<p>The <code>.times</code> methods is like a super compact <code>for</code> loop: it can perform a task on each item in a object a specified number of times.
~~~
10.times { print “Chunky bacon!” }
~~~</p>

<h2 id="blockproclambda">Block,Proc,Lambda</h2>

<p><code>Block</code>: A Ruby block is just a bit of code that can be excuted.</p>

<h3 id="bolck">Bolck</h3>

<pre><code class="language-ruby">
my_nums = [1,2,3]
#.collection
my_nums.collection { |num| num ** 2 }
# return [1,4,9]
my_nums.collection! { |num| num ** 2 }
# return [1,4,9] &amp;&amp; my_nums == [1,4,9]


#.each
[1, 2, 3].each do |num|
  puts num
end
# ==&gt; Prints 1, 2, 3 on separate lines
[1, 2, 3].each { |num| puts num }
</code></pre>

<h3 id="yied">Yied</h3>

<pre><code class="language-ruby">def block_test
  puts "We're in the method!"
  puts "Yielding to the block..."
  yield
  puts "We're back in the method!"
end

block_test { puts "&gt;&gt;&gt; We're in the block!" }


def double(n)
    puts "Ori input is #{n}"
    yield(n)
end

double(2) { |n| puts n *2}
</code></pre>

<h3 id="proc">Proc</h3>
<p>Procs are easy to define! You just call <code>Proc.new</code> and pass in the block you want to save.</p>

<ul>
  <li>Procs are full-fledged object.</li>
  <li>This prevents you from haveing to retype the contents of your block every time you need to execute a particular bit of code.</li>
</ul>

<pre><code class="language-ruby">multiples_of_3 = Proc.new do |n|
  n % 3 == 0
end

(1..100).to_a.select(&amp;multiples_of_3)

multiples_of_3.call
</code></pre>

<h3 id="lambda">Lambda</h3>

<pre><code>lambda { |param| block }

lambda { puts "Hello!" }
</code></pre>

<h3 id="lambda-vs-proc">Lambda VS. Proc</h3>

<ul>
  <li>A lambda checks the number of arguments passed to it , while a proc does not. This means that a lambda will throw an error if you pass it the worng number of arguments, whereas a proc will ignore unexpected arguments and assign <code>nil</code> to any that are missing.</li>
  <li>When a lambda returns , it passes control back to the calling methods; when a proc returns, it does so immediately, without going back to the calling methods.</li>
</ul>

<h1 id="class">Class</h1>

<h3 id="create-a-class">Create a class</h3>

<pre><code class="language-ruby">class Message
    @@messages_sent = 0
    def initialize(from, to)
        @from = from
        @to = to
        @@messages_sent += 1
    end
end

my_message = Message.new("wing.of.war","Zhangejue")
</code></pre>

<p>if you want to end a Ruby statement without going to a new line, you can just type a semicolon.</p>

<pre><code class="language-ruby">class Monkey
end

to 

class Monkey;end
</code></pre>

<h3 id="set--get">Set &amp; Get</h3>

<p>That <code>name=</code> might look funny, but you’re allowed to put an <code>=</code> sign in a methods name.
~~~
def name
  @name
end</p>

<p>def name=(value)
  @name = value
end</p>

<pre><code>*equal*
</code></pre>
<p>attr_reader :name
attr_writer :job
attr_accessor :job
~~~</p>

<h2 id="class-variable">Class Variable</h2>

<ul>
  <li>We can create class variable by starting a variable name with two @</li>
  <li>Only one copy of a class variable shared by all instances of a class.</li>
</ul>

<pre><code class="language-ruby">class MyClass
	@@class_variable
end
</code></pre>

<ul>
  <li>class variable should use a class method to grab it.</li>
</ul>

<h2 id="inheritance">Inheritance</h2>

<pre><code class="language-ruby">class ChildClass &lt; FatherClass
end
</code></pre>

<ul>
  <li>ChildClass is called: <strong>derived class</strong> Or <strong>subclasss</strong></li>
  <li>FatherClass is called: <strong>parent</strong> or <strong>superclass</strong></li>
  <li><strong>derived class</strong> can only have one <strong>superclass</strong>, not support <strong>multiple inheritance</strong></li>
</ul>

<pre><code class="language-ruby">class DerivedClass &lt; Base
  def some_method
    super(optional args)
      # Some stuff
    end
  end
end

class Email&lt;Message
    def initialize(from, to)
        super
    end
end

</code></pre>

<h2 id="publicprivate">Public&amp;Private</h2>

<ul>
  <li>Note that everything after the <strong>public</strong> keyword through the <strong>end</strong> of the class definition will now be public unless we say otherwise.</li>
  <li>Another way to say this is that the method cannot be called with an explicit receiver.</li>
  <li>In order to access private information, we have to create public methods that know how to get it.</li>
</ul>

<h1 id="module">Module</h1>

<p>You can think of a <strong>Module</strong> as a toolbox that contains a set of methods and constants.</p>

<p>One of the main purposes of modules is to seprate methods and constants into named spaces. That is called <code>namespacing</code>.</p>

<ul>
  <li>It dosent’t make sense to include variables in modules, since variables change.</li>
</ul>

<pre><code class="language-ruby">module MyLibrary
    FAVE_BOOK = "Harry porter"
end
</code></pre>

<ul>
  <li><code>Math::PI</code> and <code>Circle::PI</code>, This is called the <strong>scope resolution operator</strong></li>
</ul>

<h4 id="inlcude-a-module">inlcude a module…</h4>
<pre><code class="language-ruby">class Angle
  include Math
  attr_accessor :radians
  
  def initialize(radians)
    @radians = radians
  end
  
  def cosine
    cos(@radians)
  end
end
</code></pre>

<h2 id="mixin">Mixin</h2>

<p>When a module is used to mix addtional behavior and information into a class, it’s called <strong>mixin</strong></p>

<ul>
  <li><code>include</code> mixed a module’s methods in at the instance level.</li>
  <li><code>extend</code> keyword mixes a module’s methods at the <code>class</code> level.</li>
</ul>

