<h1 id="the-official-raywenderlichcom-objective-c-style-guide">The official raywenderlich.com Objective-C style guide.</h1>

<p>This style guide outlines the coding conventions for raywenderlich.com.</p>

<ul>
  <li>这份代码规范由<a href="raywenderlich.com">raywenderlich.com</a>编写，原文<a href="https://github.com/raywenderlich/objective-c-style-guide">Git</a>;</li>
  <li>中文注释部分由 <a href="http://wing-of-war.github.io/">wing.of.war.1980th@gmail</a> 编写于段落的加重部分;</li>
  <li>中文主要是对代码规范要点解释，部分为补充说明。</li>
</ul>

<!-- more -->

<h2 id="introduction">Introduction</h2>

<p>The reason we made this style guide was so that we could keep the code in our books, tutorials, and starter kits nice and consistent - even though we have many different authors working on the books.</p>

<p>This style guide is different from other Objective-C style guides you may see, because the focus is centered on readability for print and the web. Many of the decisions were made with an eye toward conserving space for print, easy legibility, and tutorial writing.</p>

<h2 id="credits-">Credits 编写名单</h2>

<p>The creation of this style guide was a collaborative effort from various raywenderlich.com team members under the direction of Nicholas Waynik.  The team includes: <a href="https://github.com/moayes">Soheil Moayedi Azarpour</a>, <a href="https://github.com/ricardo-rendoncepeda">Ricardo Rendon Cepeda</a>, <a href="https://github.com/tdahbura">Tony Dahbura</a>, <a href="https://github.com/ColinEberhardt">Colin Eberhardt</a>, <a href="https://github.com/mattjgalloway">Matt Galloway</a>, <a href="https://github.com/gregheo">Greg Heo</a>, <a href="https://github.com/hollance">Matthijs Hollemans</a>, <a href="https://github.com/elephantronic">Christopher LaPollo</a>, <a href="https://github.com/casademora">Saul Mora</a>, <a href="https://github.com/macandyp">Andy Pereira</a>, <a href="https://github.com/micpringle">Mic Pringle</a>, <a href="https://github.com/pietrorea">Pietro Rea</a>, <a href="https://github.com/funkyboy">Cesare Rocchi</a>, <a href="https://github.com/icanzilb">Marin Todorov</a>, <a href="https://github.com/ndubbs">Nicholas Waynik</a>, and <a href="https://github.com/raywenderlich">Ray Wenderlich</a></p>

<p>We would like to thank the creators of the <a href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a> and <a href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils’</a> Objective-C Style Guides.  These two style guides provided a solid starting point for this guide to be created and based upon.</p>

<h2 id="background-">Background 参考</h2>

<p>Here are some of the documents from Apple that informed the style guide. If something isn’t mentioned here, it’s probably covered in great detail in one of these:</p>

<ul>
  <li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html">The Objective-C Programming Language</a></li>
  <li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html">Cocoa Fundamentals Guide</a></li>
  <li><a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Coding Guidelines for Cocoa</a></li>
  <li><a href="http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html">iOS App Programming Guide</a></li>
</ul>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#language">Language</a></li>
  <li><a href="#code-organization">Code Organization</a></li>
  <li><a href="#spacing">Spacing</a></li>
  <li><a href="#comments">Comments</a></li>
  <li><a href="#naming">Naming</a>
    <ul>
      <li><a href="#underscores">Underscores</a></li>
    </ul>
  </li>
  <li><a href="#methods">Methods</a></li>
  <li><a href="#variables">Variables</a></li>
  <li><a href="#property-attributes">Property Attributes</a></li>
  <li><a href="#dot-notation-syntax">Dot-Notation Syntax</a></li>
  <li><a href="#literals">Literals</a></li>
  <li><a href="#constants">Constants</a></li>
  <li><a href="#enumerated-types">Enumerated Types</a></li>
  <li><a href="#case-statements">Case Statements</a></li>
  <li><a href="#private-properties">Private Properties</a></li>
  <li><a href="#booleans">Booleans</a></li>
  <li><a href="#conditionals">Conditionals</a>
    <ul>
      <li><a href="#ternary-operator">Ternary Operator</a></li>
    </ul>
  </li>
  <li><a href="#init-methods">Init Methods</a></li>
  <li><a href="#class-constructor-methods">Class Constructor Methods</a></li>
  <li><a href="#cgrect-functions">CGRect Functions</a></li>
  <li><a href="#golden-path">Golden Path</a></li>
  <li><a href="#error-handling">Error handling</a></li>
  <li><a href="#singletons">Singletons</a></li>
  <li><a href="#line-breaks">Line Breaks</a></li>
  <li><a href="#smiley-face">Smiley Face</a></li>
  <li><a href="#xcode-project">Xcode Project</a></li>
</ul>

<h2 id="language">Language</h2>

<p>US English should be used.</p>

<ul>
  <li>使用美式英语和单词拼写，见过用法语和日语拼音的变量，识别困难。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">UIColor *myColor = [UIColor whiteColor];
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">UIColor *myColour = [UIColor whiteColor];
</code></pre>

<h2 id="code-organization-">Code Organization 代码组织</h2>

<p>Use <code>#pragma mark -</code> to categorize methods in functional groupings and protocol/delegate implementations following this general structure.</p>

<ul>
  <li>
    <p>使用 <code>#pragma mark -</code> 把相同功能的代码放入同一代码区中。</p>
  </li>
  <li>
    <p>保持<code>.h</code>和<code>.m</code>文件内的代码分块一致与顺序一致。</p>
  </li>
</ul>

<p>示例：</p>

<pre><code class="language-objc">#pragma mark - Lifecycle

- (instancetype)init {...}

- (void)dealloc {...}

- (void)viewDidLoad {...}

- (void)viewWillAppear:(BOOL)animated {...}

- (void)didReceiveMemoryWarning {...}

#pragma mark - Custom Accessors

- (void)setCustomProperty:(id)value {...}

- (id)customProperty {...}

#pragma mark - IBActions

- (IBAction)submitData:(id)sender {...}

#pragma mark - Public

- (void)publicMethod {...}

#pragma mark - Private

- (void)privateMethod {...}

#pragma mark - Protocol conformance
#pragma mark - UITextFieldDelegate
#pragma mark - UITableViewDataSource
#pragma mark - UITableViewDelegate

#pragma mark - NSCopying

- (id)copyWithZone:(NSZone *)zone {...}

#pragma mark - NSObject

- (NSString *)description {...}

</code></pre>

<ul>
  <li>额外：如果有次级分组，使用 <code>#pragma mark </code>划分子代码区。</li>
</ul>

<pre><code class="language-objc">
#pragma mark - Main Func

- (void)sync;

#pragma mark Add

- (void)add:(id)obj;
- (void)adds:(NSArray *)objs;

#pragma mark Update

- (void)update:(id)obj;
- (void)update:(NSArray *)objs;

</code></pre>

<h2 id="spacing">Spacing空格</h2>

<ul>
  <li>Indent using 2 spaces (this conserves space in print and makes line wrapping less likely). Never indent with tabs. Be sure to set this preference in Xcode.
    <ul>
      <li>XCODE默认换行是4个空格，推 荐使用2个空格，让代码看起来更紧凑，</li>
      <li>设置方法:<code>xcode</code>-&gt;<code>preferences</code>-&gt;<code>Text Editing</code>-&gt;<code>Indentation</code>-&gt;<code>Indent width</code>。</li>
    </ul>
  </li>
  <li>Method braces and other braces (<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> etc.) always open on the same line as the statement but close on a new line.</li>
</ul>

<pre><code>* 方法体`{}`的开始`{`与方法和`if`/`else`/`switch`/`while`控制流方法处于同一行，`}`则需要另起一行。
</code></pre>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">if (user.isHappy) {
  //Do something
} else {
  //Do something else
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">if (user.isHappy)
{
    //Do something
}
else {
    //Do something else
}
</code></pre>

<ul>
  <li>There should be exactly one blank line between methods to aid in visual clarity and organization. Whitespace within methods should separate functionality, but often there should probably be new methods.
    <ul>
      <li>方法之间应该保持一个空行，有助于保持清晰的结构。</li>
    </ul>
  </li>
  <li>Prefer using auto-synthesis. But if necessary, <code>@synthesize</code> and <code>@dynamic</code> should each be declared on new lines in the implementation.
    <ul>
      <li>推荐使用<code>auto-property-synthesis</code>自动生成属性的Set,Get方法；</li>
      <li>如果需要，每一个<code>@synthesize</code> 和 <code>@dynamic</code>都应该独占一行。</li>
    </ul>
  </li>
  <li>Colon-aligning method invocation should often be avoided.  There are cases where a method signature may have &gt;= 3 colons and colon-aligning makes the code more readable. Please do <strong>NOT</strong> however colon align methods containing blocks because Xcode’s indenting makes it illegible.
    <ul>
      <li>多个回调模块，使用<code>{}</code>括号的对齐比使用 方法名中的<code>:</code>对齐要便于阅读。</li>
    </ul>
  </li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">// blocks are easily readable
[UIView animateWithDuration:1.0 animations:^{
  // something
} completion:^(BOOL finished) {
  // something
}];
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">// colon-aligning makes the block indentation hard to read
// 冒号对齐让block模块缩进难以阅读

[UIView animateWithDuration:1.0
                 animations:^{
                     // something
                 }
                 completion:^(BOOL finished) {
                     // something
                 }];
</code></pre>

<h2 id="comments">Comments</h2>

<p>When they are needed, comments should be used to explain <strong>why</strong> a particular piece of code does something. Any comments that are used must be kept up-to-date or deleted.</p>

<p>Block comments should generally be avoided, as code should be as self-documenting as possible, with only the need for intermittent, few-line explanations. <em>Exception: This does not apply to those comments used to generate documentation.</em></p>

<ul>
  <li>注释及时更新，或者直接删除；</li>
  <li>只有在复杂的地方才需要；</li>
  <li>代码如注释。</li>
</ul>

<h2 id="naming-">Naming 命名</h2>

<p>Apple naming conventions should be adhered to wherever possible, especially those related to <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">memory management rules</a> (<a href="http://stackoverflow.com/a/2865194/340508">NARC</a>).</p>

<p>Long, descriptive method and variable names are good.</p>

<ul>
  <li>鼓励使用完整，并且有描述性的变量名和方法。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">UIButton *settingsButton;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">UIButton *setBut;
</code></pre>

<p>A three letter prefix should always be used for class names and constants, however may be omitted for Core Data entity names. For any official raywenderlich.com books, starter kits, or tutorials, the prefix ‘RWT’ should be used.</p>

<ul>
  <li>三个首字母的缩写仅用于类名和常量之中。（并且大写）</li>
</ul>

<p>Constants should be camel-case with all words capitalized and prefixed by the related class name for clarity.</p>

<ul>
  <li>驼峰命名。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">static NSTimeInterval const fadetime = 1.7;
</code></pre>

<p>Properties should be camel-case with the leading word being lowercase. Use auto-synthesis for properties rather than manual @synthesize statements unless you have good reason.</p>

<ul>
  <li>如果充分的理由，使用自动变量赋值方法，而不是自己实现<code>@synthesize</code>。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">@property (strong, nonatomic) NSString *descriptiveVariableName;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">id varnm;
</code></pre>

<h3 id="underscores">Underscores</h3>

<p>When using properties, instance variables should always be accessed and mutated using <code>self.</code>. This means that all properties will be visually distinct, as they will all be prefaced with <code>self.</code>. </p>

<p>An exception to this: inside initializers, the backing instance variable (i.e. _variableName) should be used directly to avoid any potential side effects of the getters/setters.</p>

<ul>
  <li>除了init初始化方法中使用<code>_variableName</code>来获取或者设置值之外，都应该使用<code>self.</code>来获取变量，实例中的值。</li>
</ul>

<p>Local variables should not contain underscores.</p>

<ul>
  <li>本地变量不应该包含下划线。</li>
</ul>

<h2 id="methods">Methods</h2>

<p>In method signatures, there should be a space after the method type (-/+ symbol). </p>

<ul>
  <li>方法名和方法类型<code>（-/+）</code>之间有一个空格。</li>
</ul>

<p>There should be a space between the method segments (matching Apple’s style). </p>

<ul>
  <li>方法片段间有空格。</li>
</ul>

<p>Always include a keyword and be descriptive with the word before the argument which describes the argument.</p>

<p>The usage of the word “and” is reserved.  It should not be used for multiple parameters as illustrated in the <code>initWithWidth:height:</code> example below.</p>

<ul>
  <li>多个参数名前的方法要有描述性的关键字,并且不要包含<strong>and</strong>字段。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">- (void)setExampleText:(NSString *)text image:(UIImage *)image;
- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">-(void)setT:(NSString *)text i:(UIImage *)image;
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
- (instancetype)initWith:(int)width and:(int)height;  // Never do this.
</code></pre>

<p><strong>Particular：参数名在方法的最后</strong></p>

<pre><code class="language-objc">- (id)viewWithTag:(NSInteger)tag;
//Not Preferred
- (id)taggedView:(NSInteger)tag;
</code></pre>

<h2 id="variables">Variables</h2>

<p>Variables should be named as descriptively as possible. Single letter variable names should be avoided except in <code>for()</code> loops.</p>

<ul>
  <li>除了在流控制方法中的临时变量，变量名应该是有一定描述性的。</li>
</ul>

<p>Asterisks indicating pointers belong with the variable, e.g., <code>NSString *text</code> not <code>NSString* text</code> or <code>NSString * text</code>, except in the case of constants.</p>

<ul>
  <li><code>*</code>与变量名紧靠在一起。</li>
</ul>

<p><a href="#private-properties">Private properties</a> should be used in place of instance variables whenever possible. Although using instance variables is a valid way of doing things, by agreeing to prefer properties our code will be more consistent. </p>

<p>Direct access to instance variables that ‘back’ properties should be avoided except in initializer methods (<code>init</code>, <code>initWithCoder:</code>, etc…), <code>dealloc</code> methods and within custom setters and getters. For more information on using Accessor Methods in Initializer Methods and dealloc, see <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6">here</a>.</p>

<ul>
  <li>除<code>init</code>,<code>dealloc</code>，<code>set</code>,<code>get</code>等此类方法，应该尽量使用<code>setters</code>和<code>getters</code>。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">@interface RWTTutorial : NSObject

@property (strong, nonatomic) NSString *tutorialName;

@end
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">@interface RWTTutorial : NSObject {
  NSString *tutorialName;
}
</code></pre>

<h2 id="property-attributes">Property Attributes</h2>

<p>Property attributes should be explicitly listed, and will help new programmers when reading the code.  The order of properties should be storage then atomicity, which is consistent with automatically generated code when connecting UI elements from Interface Builder.</p>

<ul>
  <li>变量申明时，原子属性在存储之后。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">@property (weak, nonatomic) IBOutlet UIView *containerView;
@property (strong, nonatomic) NSString *tutorialName;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">@property (nonatomic, weak) IBOutlet UIView *containerView;
@property (nonatomic) NSString *tutorialName;
</code></pre>

<p>Properties with mutable counterparts (e.g. NSString) should prefer <code>copy</code> instead of <code>strong</code>. 
Why? Even if you declared a property as <code>NSString</code> somebody might pass in an instance of an <code>NSMutableString</code> and then change it without you noticing that.  </p>

<ul>
  <li>经常变更的变量更倾向于使用<code>copy</code>，而不是<code>strong</code>。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">@property (copy, nonatomic) NSString *tutorialName;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">@property (strong, nonatomic) NSString *tutorialName;
</code></pre>

<ul>
  <li>以下引用<a href="http://blog.csdn.net/itianyi/article/details/9018567">NSString什么时候用copy，什么时候用strong</a>对此例进行说明。</li>
</ul>

<pre><code class="language-objc">@property (retain,nonatomic) NSString *rStr;
@property (copy, nonatomic)   NSString *cStr;

- (void)test:
{
    NSMutableString *mStr = [NSMutableStringstringWithFormat:@"abc"];
    self.rStr   = mStr;
    self.cStr     = mStr;
    NSLog(@"mStr:%p,%p",  mStr,&amp;mStr);
    NSLog(@"retainStr:%p,%p", _rStr, &amp;_rStr);
    NSLog(@"copyStr:%p,%p",   _cStr, &amp;_cStr);
｝

/*
假如，mStr对象的地址为0x11，也就是0x11是@“abc”的首地址，mStr变量自身在内存中的地址为0x123；
当把mStr赋值给retain的rStr时，rStr对象的地址为0x11，rStr变量自身在内存中的地址为0x124；rStr与mStr指向同样的地址，他们指向的是同一个对象@“abc”，这个对象的地址为0x11，所以他们的值是一样的。
当把mStr赋值给copy的cStr时，cStr对象的地址为0x22，cStr变量自身在内存中的地址0x125；cStr与mStr指向的地址是不一样的，他们指向的是不同的对象，所以copy是深复制，一个新的对象，这个对象的地址为0x22，值为@“abc”。

如果现在改变mStr的值：
    [mStr appendString:@"de"];
    NSLog(@"retainStr:%@",  _rStr);
    NSLog(@"copyStr:%@",    _cStr);

结果，
使用retain的字串rStr的值：@"abcde",
而使用copy的字串cStr的值:@"abc",
所以，如果一般情况下，我们都不希望字串的值跟着mStr变化，所以我们一般用copy来设置string的属性。
如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。
注意：上面的情况是针对于当把NSMutableString赋值给NSString的时候，才会有不同，如果是赋值是NSString对象，那么使用copy还是strong，结果都是一样的，因为NSString对象根本就不能改变自身的值，他是不可变的。

把一个对象赋值给一个属性变量，当这个对象变化了，如果希望属性变量变化就使用strong属性，如果希望属性变量不跟着变化，就是用copy属性。
*/
</code></pre>

<h2 id="dot-notation-syntax--">Dot-Notation Syntax 点表达式 句法</h2>

<p>Dot syntax is purely a convenient wrapper around accessor method calls. When you use dot syntax, the property is still accessed or changed using getter and setter methods.  Read more <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html">here</a></p>

<p>Dot-notation should <strong>always</strong> be used for accessing and mutating properties, as it makes code more concise. Bracket notation is preferred in all other instances.</p>

<ul>
  <li>
    <p>点表达式应该是用于获取或者改变属性</p>
  </li>
  <li>
    <p>其它实例方法，都推荐使用<code>[]</code><strong>括号记法</strong>。</p>
  </li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">NSInteger arrayCount = [self.array count];
view.backgroundColor = [UIColor orangeColor];
[UIApplication sharedApplication].delegate;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">NSInteger arrayCount = self.array.count;
[view setBackgroundColor:[UIColor orangeColor]];
UIApplication.sharedApplication.delegate;
</code></pre>

<h2 id="literals-">Literals 字面量</h2>

<ul>
  <li>
    <p>Literals翻译成字面量或者字面值，就是直接被写到源代码中的值<a href="http://my.oschina.net/iamzkt/blog/127718">Objective-C 之 Literals（字面量）</a>。</p>
  </li>
  <li>
    <p>它的语法很简单，上面的代码就是通过在C字符串的前面加上@符号创建了一个NSString对象greeting，整段代码看起来简洁易懂，如果没有直接量语法，那么创建这个greeting可能就要使用下面的方法了：
~~~objc
NSString *greeting = [NSString stringWithUTF8String:”Hello World”];
~~~</p>
  </li>
</ul>

<p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, and <code>NSNumber</code> literals should be used whenever creating immutable instances of those objects. Pay special care that <code>nil</code> values can not be passed into <code>NSArray</code> and <code>NSDictionary</code> literals, as this will cause a crash.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
NSDictionary *productManagers = @{@"iPhone": @"Kate", @"iPad": @"Kamal", @"Mobile Web": @"Bill"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingStreetNumber = @10018;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018];
</code></pre>

<h2 id="constants-">Constants 常量</h2>

<p>Constants are preferred over in-line string literals or numbers, as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace. Constants should be declared as <code>static</code> constants and not <code>#define</code>s unless explicitly being used as a macro.</p>

<ul>
  <li>常量使用<code>static</code>与<code>const</code>创建，<code>#define</code>可以用于定义便利方法。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">static NSString * const RWTAboutViewControllerCompanyName = @"RayWenderlich.com";

static CGFloat const RWTImageThumbnailHeight = 50.0;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">#define CompanyName @"RayWenderlich.com"

#define thumbnailHeight 2
</code></pre>

<h2 id="enumerated-types">Enumerated Types</h2>

<p>When using <code>enum</code>s, it is recommended to use the new fixed underlying type specification because it has stronger type checking and code completion. The SDK now includes a macro to facilitate and encourage use of fixed underlying types: <code>NS_ENUM()</code></p>

<ul>
  <li>推荐使用代码提示中宏定义的<code>NS_ENUM()</code>枚举模块来创建，它可以提供更严谨的类型检测和代码补完功能。</li>
</ul>

<p><strong>For Example:</strong></p>

<pre><code class="language-objc">typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) {
  RWTLeftMenuTopItemMain,
  RWTLeftMenuTopItemShows,
  RWTLeftMenuTopItemSchedule
};
</code></pre>

<p>You can also make explicit value assignments (showing older k-style constant definition):</p>

<pre><code class="language-objc">typedef NS_ENUM(NSInteger, RWTGlobalConstants) {
  RWTPinSizeMin = 1,
  RWTPinSizeMax = 5,
  RWTPinCountMin = 100,
  RWTPinCountMax = 500,
};
</code></pre>

<p>Older k-style constant definitions should be <strong>avoided</strong> unless writing CoreFoundation C code (unlikely).</p>

<ul>
  <li>传统的枚举则让代码看起来更像C。</li>
</ul>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">enum GlobalConstants {
  kMaxPinSize = 5,
  kMaxPinCount = 500,
};
</code></pre>

<h2 id="case-statements-">Case Statements 分支</h2>

<p>Braces are not required for case statements, unless enforced by the complier.<br />
When a case contains more than one line, braces should be added.</p>

<ul>
  <li>每一个<code>case</code>分支下的执行语句，如果只有一行，不加<code>{}</code>；</li>
  <li>如果<code>case</code>分支下的执行语句有多行，则使用<code>{}</code>划定范围。</li>
</ul>

<pre><code class="language-objc">switch (condition) {
  case 1:
    // ...
    break;
  case 2: {
    // ...
    // Multi-line example using braces
    break;
  }
  case 3:
    // ...
    break;
  default: 
    // ...
    break;
}

</code></pre>

<p>There are times when the same code can be used for multiple cases, and a fall-through should be used.  A fall-through is the removal of the ‘break’ statement for a case thus allowing the flow of execution to pass to the next case value.  A fall-through should be commented for coding clarity.</p>

<ul>
  <li>相同<code>case</code>分支的条件使用<code>条件继承 fall-through</code>，在上层<code>case</code>中不使用<code>break</code>跳出，直接继承下层<code>case</code>的执行语句。</li>
</ul>

<pre><code class="language-objc">switch (condition) {
  case 1:
    // ** fall-through! **
  case 2:
    // code executed for values 1 and 2
    break;
  default: 
    // ...
    break;
}

</code></pre>

<p>When using an enumerated type for a switch, ‘default’ is not needed.   For example:</p>

<ul>
  <li><code>default</code>条件非必需</li>
</ul>

<pre><code class="language-objc">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;

switch (menuType) {
  case RWTLeftMenuTopItemMain:
    // ...
    break;
  case RWTLeftMenuTopItemShows:
    // ...
    break;
  case RWTLeftMenuTopItemSchedule:
    // ...
    break;
}
</code></pre>

<h2 id="private-properties">Private Properties</h2>

<p>Private properties should be declared in class extensions (anonymous categories) in the implementation file of a class. Named categories (such as <code>RWTPrivate</code> or <code>private</code>) should never be used unless extending another class.   The Anonymous category can be shared/exposed for testing using the <headerfile>+Private.h file naming convention.</headerfile></p>

<ul>
  <li>
    <p>私有变更应该在类的私有类别中，不需要加<code>private</code>等词语来进行修饰。</p>
  </li>
  <li>
    <p>私有类别可以在命名为<code>&lt;headerfile&gt;+Private.h</code>的文件里提供</p>
  </li>
</ul>

<p><strong>For Example:</strong></p>

<pre><code class="language-objc">@interface RWTDetailViewController ()

@property (strong, nonatomic) GADBannerView *googleAdView;
@property (strong, nonatomic) ADBannerView *iAdView;
@property (strong, nonatomic) UIWebView *adXWebView;

@end
</code></pre>

<h2 id="booleans">Booleans</h2>

<p>Objective-C uses <code>YES</code> and <code>NO</code>.  Therefore <code>true</code> and <code>false</code> should only be used for CoreFoundation, C or C++ code.  Since <code>nil</code> resolves to <code>NO</code> it is unnecessary to compare it in conditions. </p>

<p>Never compare something directly to <code>YES</code>, because <code>YES</code> is defined to 1 and a <code>BOOL</code> can be up to 8 bits.</p>

<ul>
  <li>不要把对象直接和<code>YES</code>进行比较，</li>
  <li>可以覆写类继承自<code>NSOjbect</code>下的<code>-(BOOL)isEqual:(id)obj;</code>方法来类的比较。</li>
</ul>

<p>This allows for more consistency across files and greater visual clarity.</p>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">if (someObject) {}
if (![anotherObject boolValue]) {}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">if (someObject == nil) {}
if ([anotherObject boolValue] == NO) {}
if (isAwesome == YES) {} // Never do this.
if (isAwesome == true) {} // Never do this.
</code></pre>

<p>If the name of a <code>BOOL</code> property is expressed as an adjective, the property can omit the “is” prefix but specifies the conventional name for the get accessor, for example:</p>

<ul>
  <li>如果<code>BOOL</code>变量是形容词，不需要<strong>is</strong>来进行修饰。</li>
</ul>

<pre><code class="language-objc">@property (assign, getter=isEditable) BOOL editable;
//**Not Preferred:**
//@property (assign, getter=isEditable) BOOL isEditable;

</code></pre>

<p>Text and example taken from the <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE">Cocoa Naming Guidelines</a>.</p>

<h2 id="conditionals">Conditionals</h2>

<p>Conditional bodies should always use braces even when a conditional body could be written without braces (e.g., it is one line only) to prevent errors. These errors include adding a second line and expecting it to be part of the if-statement. Another, <a href="http://programmers.stackexchange.com/a/16530">even more dangerous defect</a> may happen where the line “inside” the if-statement is commented out, and the next line unwittingly becomes part of the if-statement. In addition, this style is more consistent with all other conditionals, and therefore more easily scannable.</p>

<ul>
  <li>
    <p>一定使用<code>{}</code>来划定判断后的执行语句；</p>
  </li>
  <li>
    <p>即使执行语非常简单，也不能与条件判断在一行。</p>
  </li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">if (!error) {
  return success;
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">if (!error)
  return success;
</code></pre>

<p>or</p>

<pre><code class="language-objc">if (!error) return success;
</code></pre>

<h3 id="ternary-operator-">Ternary Operator 三元运算符</h3>

<p>The Ternary operator, <code>?:</code> , should only be used when it increases clarity or code neatness. </p>

<ul>
  <li>只有在确定能够促进代码整洁与清晰的前提下才使用。</li>
</ul>

<p>A single condition is usually all that should be evaluated. Evaluating multiple conditions is usually more understandable as an <code>if</code> statement, or refactored into instance variables. </p>

<p>In general, the best use of the ternary operator is during assignment of a variable and deciding which value to use.</p>

<ul>
  <li>三元运算符最好在赋值需要判断时使用。</li>
</ul>

<p>Non-boolean variables should be compared against something, and parentheses are added for improved readability.  If the variable being compared is a boolean type, then no parentheses are needed.</p>

<ul>
  <li>非BOOL类型变量必须要与其类型变量做出判断后才能使用。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">NSInteger value = 5;
result = (value != 0) ? x : y;

BOOL isHorizontal = YES;
result = isHorizontal ? x : y;
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">result = a &gt; b ? x = c &gt; d ? c : d : y;
</code></pre>

<h2 id="init-methods">Init Methods</h2>

<p>Init methods should follow the convention provided by Apple’s generated code template.  A return type of ‘instancetype’ should also be used instead of ‘id’.</p>

<ul>
  <li><code>init</code>方法中返回值使用<code>instancetype</code>取代<code>id</code>作为返回。</li>
</ul>

<pre><code class="language-objc">- (instancetype)init {
  self = [super init];
  if (self) {
    // ...
  }
  return self;
}
</code></pre>

<p>See <a href="#class-constructor-methods">Class Constructor Methods</a> for link to article on instancetype.</p>

<h2 id="class-constructor-methods">Class Constructor Methods</h2>

<p>Where class constructor methods are used, these should always return type of ‘instancetype’ and never ‘id’. This ensures the compiler correctly infers the result type. </p>

<pre><code class="language-objc">@interface Airplane
+ (instancetype)airplaneWithType:(RWTAirplaneType)type;
@end
</code></pre>

<p>More information on instancetype can be found on <a href="http://nshipster.com/instancetype/">NSHipster.com</a>.</p>

<ul>
  <li>以下摘取自<a href="http://blog.csdn.net/wzzvictory/article/details/16994913">Objective-C中的instancetype和id关键字</a>。</li>
</ul>

<pre><code>三、instancetype作用
1、作用
如果一个不是关联返回类型的方法，如下：

@interface NSArray  
+ (id)constructAnArray;  
@end  
当我们使用如下方式初始化NSArray时：


[NSArray constructAnArray];  
根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id。
但是如果使用instancetype作为返回类型，如下：


@interface NSArray  
+ (instancetype)constructAnArray;  
@end  
当使用相同方式初始化NSArray时：

[NSArray constructAnArray];  
得到的返回类型和方法所在类的类型相同，是NSArray*!
总结一下，instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！

2、好处
能够确定对象的类型，能够帮助编译器更好的为我们定位代码书写问题，比如：

[[[NSArray alloc] init] mediaPlaybackAllowsAirPlay]; //  "No visible @interface for `NSArray` declares the selector `mediaPlaybackAllowsAirPlay`"  
  
[[NSArray array] mediaPlaybackAllowsAirPlay]; // (No error)  
上例中第一行代码，由于[[NSArray alloc]init]的结果是NSArray*，这样编译器就能够根据返回的数据类型检测出NSArray是否实现mediaPlaybackAllowsAirPlay方法。有利于开发者在编译阶段发现错误。
第二行代码，由于array不属于关联返回类型方法，[NSArray array]返回的是id类型，编译器不知道id类型的对象是否实现了mediaPlaybackAllowsAirPlay方法，也就不能够替开发者及时发现错误。
</code></pre>

<h2 id="cgrect-functions">CGRect Functions</h2>

<p>When accessing the <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code> of a <code>CGRect</code>, always use the <a href="http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html"><code>CGGeometry</code> functions</a> instead of direct struct member access. From Apple’s <code>CGGeometry</code> reference:</p>

<blockquote>
  <p>All functions described in this reference that take CGRect data structures as inputs implicitly standardize those rectangles before calculating their results. For this reason, your applications should avoid directly reading and writing the data stored in the CGRect data structure. Instead, use the functions described here to manipulate rectangles and to retrieve their characteristics.</p>
</blockquote>

<ul>
  <li>使用<code>CGGeometry</code>方法来获取<code>CGRect</code>结构下的长宽位置值。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">CGRect frame = self.view.frame;

CGFloat x = CGRectGetMinX(frame);
CGFloat y = CGRectGetMinY(frame);
CGFloat width = CGRectGetWidth(frame);
CGFloat height = CGRectGetHeight(frame);
CGRect frame = CGRectMake(0.0, 0.0, width, height);
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">CGRect frame = self.view.frame;

CGFloat x = frame.origin.x;
CGFloat y = frame.origin.y;
CGFloat width = frame.size.width;
CGFloat height = frame.size.height;
CGRect frame = (CGRect){ .origin = CGPointZero, .size = frame.size };
</code></pre>

<h2 id="golden-path">Golden Path</h2>

<p>When coding with conditionals, the left hand margin of the code should be the “golden” or “happy” path.  That is, don’t nest <code>if</code> statements.  Multiple return statements are OK.</p>

<ul>
  <li>
    <p>条件判断的左侧空间被称为<strong>黄金路径</strong>或者<strong>幸福路径</strong>；</p>
  </li>
  <li>
    <p>减少<code>if</code>的条件的嵌套，扁平化多个返回条件。</p>
  </li>
  <li>
    <p>函数的多个返回条件是可以接受的。</p>
  </li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">- (void)someMethod {
  if (![someOther boolValue]) {
	return;
  }

  //Do something important
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">- (void)someMethod {
  if ([someOther boolValue]) {
    //Do something important
  }
}
</code></pre>

<p><strong>Demo:</strong></p>

<pre><code class="language-objc">    if (text.length &gt; 0) {
        WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
        if (contact) {
            [_sentTo addObject:contact];
            [self setSearchTableShow:NO];
            tokenField.inputText = @"";
            [tokenField reloadData];
       }
    } else {
        [_subjectTokenField becomeFirstResponder];
    }

//Rebuild:

    if (text.length &lt;= 0) {
        [_subjectTokenField becomeFirstResponder];
        return;
    }
    WVContact* contact = [[WVContact alloc] initContact:text combName:text withLastModify:nil];
    if (!contact) {
        return;
    }
    [_sentTo addObject:contact];
    [self setSearchTableShow:NO];
    tokenField.inputText = @"";
    [tokenField reloadData];

</code></pre>

<h2 id="error-handling">Error handling</h2>

<p>When methods return an error parameter by reference, switch on the returned value, not the error variable.</p>

<ul>
  <li>条件判断错误时，应该是错误变量本身。</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">NSError *error;
if (![self trySomethingWithError:&amp;error]) {
  // Handle Error
}
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">NSError *error;
[self trySomethingWithError:&amp;error];
if (error) {
  // Handle Error
}
</code></pre>

<p>Some of Apple’s APIs write garbage values to the error parameter (if non-NULL) in successful cases, so switching on the error can cause false negatives (and subsequently crash).</p>

<h2 id="singletons">Singletons</h2>

<p>Singleton objects should use a thread-safe pattern for creating their shared instance.</p>

<ul>
  <li>单例必须线程安全。</li>
</ul>

<pre><code class="language-objc">+ (instancetype)sharedInstance {
  static id sharedInstance = nil;

  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
    sharedInstance = [[self alloc] init];
  });

  return sharedInstance;
}
</code></pre>
<p>This will prevent <a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html">possible and sometimes prolific crashes</a>.</p>

<h2 id="line-breaks">Line Breaks</h2>

<p>Line breaks are an important topic since this style guide is focused for print and online readability.</p>

<p>For example:</p>

<pre><code class="language-objc">self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers];
</code></pre>
<p>A long line of code like this should be carried on to the second line adhering to this style guide’s Spacing section (two spaces).</p>

<ul>
  <li>因为代码太长需要换行时，与首行有两个空格间隔；</li>
  <li>设置方法：<code>xcode</code>-&gt;<code>preferences</code>-&gt;<code>Text Editing</code>-&gt;<code>Indentation</code>-&gt;<code>Line Wrapping</code> 手动设置为<code>2</code>。</li>
</ul>

<pre><code class="language-objc">self.productsRequest = [[SKProductsRequest alloc] 
  initWithProductIdentifiers:productIdentifiers];
</code></pre>

<h2 id="smiley-face">Smiley Face</h2>

<p>Smiley faces are a very prominent style feature of the raywenderlich.com site!  It is very important to have the correct smile signifying the immense amount of happiness and excitement for the coding topic.  The end square bracket is used because it represents the largest smile able to be captured using ascii art.  A half-hearted smile is represented if an end parenthesis is used, and thus not preferred.</p>

<ul>
  <li>使用<code>]</code>看起来比<code>)</code>笑得更开心</li>
</ul>

<p><strong>Preferred:</strong></p>

<pre><code class="language-objc">:]
</code></pre>

<p><strong>Not Preferred:</strong></p>

<pre><code class="language-objc">:)
</code></pre>

<h2 id="xcode-project">Xcode project</h2>

<p>The physical files should be kept in sync with the Xcode project files in order to avoid file sprawl. Any Xcode groups created should be reflected by folders in the filesystem. Code should be grouped not only by type, but also by feature for greater clarity.</p>

<p>When possible, always turn on “Treat Warnings as Errors” in the target’s Build Settings and enable as many <a href="http://boredzo.org/blog/archives/2009-11-07/warnings">additional warnings</a> as possible. If you need to ignore a specific warning, use <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">Clang’s pragma feature</a>.</p>

<h1 id="other-objective-c-style-guides">Other Objective-C Style Guides</h1>

<p>If ours doesn’t fit your tastes, have a look at some other style guides:</p>

<ul>
  <li><a href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils</a></li>
  <li><a href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a></li>
  <li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">Google</a></li>
  <li><a href="https://github.com/github/objective-c-conventions">GitHub</a></li>
  <li><a href="https://trac.adium.im/wiki/CodingStyle">Adium</a></li>
  <li><a href="https://gist.github.com/soffes/812796">Sam Soffes</a></li>
  <li><a href="http://cocoadevcentral.com/articles/000082.php">CocoaDevCentral</a></li>
  <li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html">Luke Redpath</a></li>
  <li><a href="http://www.cimgf.com/zds-code-style-guide/">Marcus Zarra</a></li>
</ul>
